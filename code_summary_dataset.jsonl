{"code": "def create_user(self, username: str, email: str, phone: Optional[str] = None) -> User: \n    \"\"\" \n    Create a new user. \n     \n    Args: \n        username: User's username \n        email: User's email address \n        phone: User's phone number (optional) \n     \n    Returns: \n        Created user object \n     \n    Raises: \n        ValueError: If required fields are missing or invalid \n    \"\"\" \n    data = {'username': username, 'email': email} \n    if not validate_required_fields(data, ['username', 'email']): \n        raise ValueError(\"Username and email are required\") \n     \n    user = User( \n        id=self._next_id, \n        username=username, \n        email=email, \n        phone=phone \n    ) \n     \n    self.users.append(user) \n    self._next_id += 1 \n    logger.info(f\"Created user: {username} (ID: {user.id})\") \n     \n    return user", "summary": "The UserService.create_user method is a decorated instance method that creates and persists new user objects with validation and logging. From an AST perspective, it's decorated with @log_execution_time and accepts username, email, and optional phone parameters, returning a User object. The control flow begins by constructing a validation dictionary and branches on validate_required_fields() - the false branch raises a ValueError while the true branch proceeds to instantiate a User object with an auto-incremented ID from self._next_id. The method then mutates instance state by appending the user to self.users and incrementing the ID counter, followed by a logging call before returning the created user. In the call graph, it has outbound dependencies on validate_required_fields() from validators, the User constructor (which internally triggers __post_init__ validation via validate_email() and validate_phone()), and logger.info() for audit logging. The decorator wrapper also logs execution time. Inbound calls primarily come from APIRouter.handle_create_user() in the API layer, establishing this method as the core business logic layer for user creation with validation, state management, and observability concerns."}
{"code": "def process_payment(self, amount: float, currency: str, method: str) -> PaymentResult:\n    \"\"\"\n    Process a payment transaction.\n    \"\"\"\n    if amount <= 0:\n        raise ValueError(\"Amount must be positive\")\n\n    if method not in self.supported_methods:\n        raise ValueError(f\"Unsupported payment method: {method}\")\n\n    transaction = Transaction(amount=amount, currency=currency, method=method, status='pending')\n    self.db.save(transaction)\n\n    try:\n        gateway_response = self.payment_gateway.charge(amount, currency, method)\n        if gateway_response.success:\n            transaction.status = 'completed'\n            transaction.id = gateway_response.id\n            self.email_service.send_receipt(transaction)\n        else:\n            transaction.status = 'failed'\n            logger.error(f\"Payment failed: {gateway_response.error}\")\n    except Exception as e:\n        transaction.status = 'error'\n        logger.exception(\"Payment processing error\")\n        raise e\n    finally:\n        self.db.update(transaction)\n\n    return PaymentResult(transaction)", "summary": "The PaymentService.process_payment method handles the end-to-end lifecycle of a financial transaction. Structurally, it begins with input validation guards that raise ValueErrors for invalid amounts or unsupported methods. The control flow then instantiates a pending Transaction object and persists it via self.db.save(). A try-except-finally block manages the external integration with self.payment_gateway.charge(); successful charges transition the state to 'completed' and trigger an async email receipt via self.email_service, while failures are logged and marked as 'failed'. Exceptions catch unhandled errors, updating the status to 'error' before re-raising. The finally block ensures persistence consistency by calling self.db.update(transaction) regardless of the outcome. Key dependencies include the database abstraction, the external payment gateway adapter, and the notification service."}
{"code": "def load_config(self, config_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Load and validate configuration from a file.\n    \"\"\"\n    if not os.path.exists(config_path):\n        logger.warning(f\"Config file not found at {config_path}, using defaults\")\n        return self.default_config.copy()\n\n    with open(config_path, 'r') as f:\n        try:\n            config = yaml.safe_load(f)\n        except yaml.YAMLError as e:\n            logger.error(f\"Error parsing config: {e}\")\n            raise ConfigError(\"Invalid YAML format\") from e\n\n    if 'version' not in config:\n         config['version'] = 1\n\n    merged_config = self._merge_with_defaults(config)\n    self._validate_config_schema(merged_config)\n    \n    logger.info(f\"Configuration loaded from {config_path}\")\n    return merged_config", "summary": "The ConfigLoader.load_config method is responsible for retrieving and preparing application configuration settings. The control flow starts with a file existence check using os.path.exists; if missing, it logs a warning and returns a copy of default settings to prevent mutation side effects. If present, it opens the file within a context manager and attempts to parse it using yaml.safe_load, wrapping parsing errors in a custom ConfigError. It conditionally injects a default version if missing. The method then performs data integration by calling the private helper _merge_with_defaults() and enforces structural integrity via _validate_config_schema(). Finally, it logs a success message and returns the validated, merged configuration dictionary. This method acts as a robust entry point for configuration management, handling file I/O, parsing, validation, and fallback logic."}
