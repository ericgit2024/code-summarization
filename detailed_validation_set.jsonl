{"code": "def create_post(user_id, title, content, tags):\n    user = UserService.get_user(user_id)\n    if not user or not user.is_active:\n        logger.error(f\"Invalid user: {user_id}\")\n        return None\n    post = Post(id=generate_id(), title=title, content=content, tags=tags, author=user)\n    posts_collection.append(post)\n    logger.info(f\"Post created: {post.id}\")\n    return post", "summary": "This function creates a new post within a social media platform by performing the following steps: First, it retrieves the user associated with the given user_id by calling UserService.get_user(). Then, it validates that the user exists and is active by checking the user object and its is_active property. If the validation fails, an error is logged using logger.error() and the function returns None. If the user is valid, a new Post object is created with a unique identifier generated by generate_id(), along with the provided title, content, tags, and the retrieved user as the author. The newly created post is then appended to the posts_collection list. A success message is logged using logger.info() to record the post creation. Finally, the function returns the created post object, allowing dependent components to access and interact with it."}
{"code": "def process_payment(order_id, payment_method, amount):\n    order = OrderService.fetch_order(order_id)\n    if not order:\n        raise ValueError(\"Order not found\")\n    if order.status != 'pending':\n        raise ValueError(\"Order already processed\")\n    transaction = PaymentGateway.charge(payment_method, amount)\n    if transaction.success:\n        order.status = 'paid'\n        order.transaction_id = transaction.id\n        OrderService.update_order(order)\n        NotificationService.send_receipt(order.customer_email, transaction)\n        return transaction\n    else:\n        raise PaymentError(transaction.error_message)", "summary": "This function processes a payment for an order by executing the following sequence of operations: First, it retrieves the order details by calling OrderService.fetch_order() with the provided order_id. If the order is not found, a ValueError is raised with the message \"Order not found\". Next, it validates that the order status is 'pending' by checking the order.status property. If the order has already been processed (status is not 'pending'), a ValueError is raised with the message \"Order already processed\". The function then attempts to charge the payment by calling PaymentGateway.charge() with the specified payment_method and amount, which returns a transaction object. If the transaction is successful (transaction.success is True), the order status is updated to 'paid', the transaction ID is stored in order.transaction_id, and the updated order is persisted by calling OrderService.update_order(). A receipt is then sent to the customer by calling NotificationService.send_receipt() with the customer's email and transaction details. Finally, the function returns the successful transaction object. If the payment fails, a PaymentError exception is raised with the transaction's error message."}
{"code": "def authenticate_user(username, password):\n    user = Database.query_user(username)\n    if not user:\n        AuditLog.record('login_failed', username, 'user_not_found')\n        return None\n    if not PasswordHasher.verify(password, user.password_hash):\n        AuditLog.record('login_failed', username, 'invalid_password')\n        user.failed_attempts += 1\n        if user.failed_attempts >= 3:\n            user.is_locked = True\n            Database.update_user(user)\n        return None\n    session_token = TokenGenerator.create_session(user.id)\n    AuditLog.record('login_success', username, session_token)\n    return session_token", "summary": "This function authenticates a user by verifying their credentials and managing login security through the following process: First, it queries the database for the user by calling Database.query_user() with the provided username. If no user is found, the function records a failed login attempt using AuditLog.record() with the reason 'user_not_found' and returns None. If the user exists, the function verifies the provided password against the stored password hash by calling PasswordHasher.verify(). If the password verification fails, a failed login attempt is recorded using AuditLog.record() with the reason 'invalid_password', and the user's failed_attempts counter is incremented. If the failed attempts reach or exceed 3, the user account is locked by setting user.is_locked to True, and the updated user record is persisted by calling Database.update_user(). The function then returns None to indicate authentication failure. If the password is correct, a new session token is generated by calling TokenGenerator.create_session() with the user's ID. A successful login is recorded using AuditLog.record() with the session token. Finally, the function returns the generated session token, allowing the user to access protected resources."}
{"code": "def generate_report(report_type, start_date, end_date, filters):\n    data = DataWarehouse.fetch_data(report_type, start_date, end_date)\n    if filters:\n        data = DataFilter.apply_filters(data, filters)\n    aggregated = DataAggregator.aggregate(data, report_type)\n    chart = ChartGenerator.create_chart(aggregated, report_type)\n    pdf = PDFRenderer.render(chart, aggregated, report_type)\n    storage_path = FileStorage.save(pdf, f\"reports/{report_type}_{start_date}_{end_date}.pdf\")\n    EmailService.send_report(storage_path, recipients=['admin@company.com'])\n    return storage_path", "summary": "This function generates and distributes a comprehensive report by performing the following operations: First, it retrieves raw data from the data warehouse by calling DataWarehouse.fetch_data() with the specified report_type, start_date, and end_date parameters. If any filters are provided, the raw data is refined by calling DataFilter.apply_filters() with the data and the filters dictionary. The filtered data is then aggregated according to the report type by calling DataAggregator.aggregate(), which computes summary statistics and metrics. A visual representation is created by calling ChartGenerator.create_chart() with the aggregated data and report type, producing a chart object. The chart and aggregated data are then rendered into a PDF document by calling PDFRenderer.render(). The generated PDF is saved to persistent storage by calling FileStorage.save() with the PDF content and a filename constructed from the report type and date range, returning the storage path. The report is then distributed by calling EmailService.send_report() with the storage path and a list of recipient email addresses (defaulting to 'admin@company.com'). Finally, the function returns the storage path where the report is saved, allowing other components to access the generated document."}
{"code": "def sync_inventory(product_id, quantity_change, warehouse_id):\n    product = InventoryDB.get_product(product_id)\n    if not product:\n        raise ProductNotFoundError(f\"Product {product_id} not found\")\n    warehouse = InventoryDB.get_warehouse(warehouse_id)\n    if not warehouse:\n        raise WarehouseNotFoundError(f\"Warehouse {warehouse_id} not found\")\n    current_stock = warehouse.stock.get(product_id, 0)\n    new_stock = current_stock + quantity_change\n    if new_stock < 0:\n        raise InsufficientStockError(f\"Cannot reduce stock below zero\")\n    warehouse.stock[product_id] = new_stock\n    InventoryDB.update_warehouse(warehouse)\n    InventoryLog.record(product_id, warehouse_id, quantity_change, new_stock)\n    if new_stock < product.reorder_threshold:\n        PurchaseService.create_reorder_request(product_id, warehouse_id)\n    return new_stock", "summary": "This function synchronizes inventory levels for a product in a specific warehouse by executing the following workflow: First, it retrieves the product details by calling InventoryDB.get_product() with the provided product_id. If the product is not found, a ProductNotFoundError is raised with a descriptive message. Next, it retrieves the warehouse information by calling InventoryDB.get_warehouse() with the warehouse_id. If the warehouse does not exist, a WarehouseNotFoundError is raised. The function then calculates the current stock level for the product in the warehouse by accessing warehouse.stock dictionary with the product_id, defaulting to 0 if the product is not yet stocked. The new stock level is computed by adding the quantity_change to the current stock. If the resulting new_stock would be negative, an InsufficientStockError is raised to prevent invalid inventory states. If the stock level is valid, the warehouse's stock dictionary is updated with the new quantity, and the changes are persisted by calling InventoryDB.update_warehouse(). An inventory change record is created by calling InventoryLog.record() with the product ID, warehouse ID, quantity change, and new stock level. The function then checks if the new stock level has fallen below the product's reorder threshold. If so, an automatic reorder request is created by calling PurchaseService.create_reorder_request(). Finally, the function returns the new stock level, allowing calling code to confirm the updated inventory quantity."}
{"code": "def schedule_meeting(organizer_id, attendee_ids, start_time, duration, room_id):\n    organizer = UserService.get_user(organizer_id)\n    if not organizer:\n        raise ValueError(\"Organizer not found\")\n    attendees = [UserService.get_user(uid) for uid in attendee_ids]\n    if None in attendees:\n        raise ValueError(\"One or more attendees not found\")\n    end_time = start_time + timedelta(minutes=duration)\n    conflicts = CalendarService.check_conflicts(attendee_ids + [organizer_id], start_time, end_time)\n    if conflicts:\n        raise SchedulingConflictError(f\"Conflicts found: {conflicts}\")\n    room = RoomService.get_room(room_id)\n    if not room or not RoomService.is_available(room_id, start_time, end_time):\n        raise RoomUnavailableError(f\"Room {room_id} not available\")\n    meeting = Meeting(organizer=organizer, attendees=attendees, start=start_time, end=end_time, room=room)\n    meeting_id = CalendarService.create_event(meeting)\n    for attendee in attendees:\n        NotificationService.send_invite(attendee.email, meeting)\n    return meeting_id", "summary": "This function schedules a meeting by coordinating multiple services and performing comprehensive validation through the following steps: First, it retrieves the organizer's user object by calling UserService.get_user() with the organizer_id. If the organizer is not found, a ValueError is raised. Next, it retrieves all attendee user objects by iterating through attendee_ids and calling UserService.get_user() for each ID, collecting the results in a list. If any attendee is not found (resulting in None in the list), a ValueError is raised with the message \"One or more attendees not found\". The meeting end time is calculated by adding the duration (in minutes) to the start_time using timedelta. The function then checks for scheduling conflicts by calling CalendarService.check_conflicts() with a combined list of all attendee IDs plus the organizer ID, along with the start and end times. If any conflicts are detected, a SchedulingConflictError is raised with details of the conflicts. The function retrieves the meeting room by calling RoomService.get_room() with the room_id and verifies room availability by calling RoomService.is_available() for the specified time range. If the room doesn't exist or is unavailable, a RoomUnavailableError is raised. A new Meeting object is created with the organizer, attendees list, start time, end time, and room. The meeting is persisted by calling CalendarService.create_event(), which returns a unique meeting_id. Finally, the function sends meeting invitations to all attendees by iterating through the attendees list and calling NotificationService.send_invite() with each attendee's email and the meeting details. The function returns the meeting_id, allowing the calling code to reference the scheduled meeting."}
{"code": "def backup_database(database_name, backup_location, compression_level):\n    db_connection = DatabaseManager.connect(database_name)\n    if not db_connection:\n        raise ConnectionError(f\"Cannot connect to database {database_name}\")\n    backup_file = f\"{backup_location}/{database_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.bak\"\n    DatabaseManager.create_snapshot(db_connection, backup_file)\n    if compression_level > 0:\n        compressed_file = Compressor.compress(backup_file, compression_level)\n        FileSystem.delete(backup_file)\n        backup_file = compressed_file\n    file_size = FileSystem.get_size(backup_file)\n    checksum = HashGenerator.compute_md5(backup_file)\n    metadata = BackupMetadata(database=database_name, file=backup_file, size=file_size, checksum=checksum, timestamp=datetime.now())\n    BackupRegistry.register(metadata)\n    DatabaseManager.disconnect(db_connection)\n    return backup_file", "summary": "This function performs a complete database backup operation with optional compression and integrity verification through the following process: First, it establishes a connection to the specified database by calling DatabaseManager.connect() with the database_name. If the connection fails, a ConnectionError is raised with a descriptive message. A backup filename is constructed using the backup_location, database_name, and the current timestamp formatted as YYYYMMDD_HHMMSS, with a .bak extension. The database snapshot is created by calling DatabaseManager.create_snapshot() with the connection and the backup filename. If a compression level greater than 0 is specified, the backup file is compressed by calling Compressor.compress() with the backup file path and compression level, which returns the path to the compressed file. The original uncompressed backup file is then deleted by calling FileSystem.delete(), and the backup_file variable is updated to reference the compressed file. The size of the final backup file (compressed or uncompressed) is retrieved by calling FileSystem.get_size(). An MD5 checksum is computed for integrity verification by calling HashGenerator.compute_md5() with the backup file path. A BackupMetadata object is created containing the database name, backup file path, file size, checksum, and current timestamp. This metadata is registered in the backup registry by calling BackupRegistry.register(). The database connection is properly closed by calling DatabaseManager.disconnect(). Finally, the function returns the path to the backup file (either compressed or uncompressed), allowing the calling code to access or transfer the backup."}
{"code": "def process_refund(order_id, refund_amount, reason):\n    order = OrderService.get_order(order_id)\n    if not order:\n        raise OrderNotFoundError(f\"Order {order_id} not found\")\n    if order.status != 'paid':\n        raise InvalidOrderStateError(\"Only paid orders can be refunded\")\n    if refund_amount > order.total_amount:\n        raise InvalidRefundAmountError(\"Refund amount exceeds order total\")\n    original_transaction = PaymentService.get_transaction(order.transaction_id)\n    refund_transaction = PaymentGateway.refund(original_transaction, refund_amount)\n    if not refund_transaction.success:\n        raise RefundFailedError(refund_transaction.error_message)\n    order.refund_amount = refund_amount\n    order.status = 'refunded' if refund_amount == order.total_amount else 'partially_refunded'\n    OrderService.update_order(order)\n    RefundLog.record(order_id, refund_amount, reason, refund_transaction.id)\n    EmailService.send_refund_confirmation(order.customer_email, refund_amount)\n    return refund_transaction.id", "summary": "This function processes a refund for a customer order by performing comprehensive validation and executing the refund workflow through the following steps: First, it retrieves the order details by calling OrderService.get_order() with the provided order_id. If the order is not found, an OrderNotFoundError is raised. The function validates that the order is in a 'paid' status by checking order.status. If the order is not paid, an InvalidOrderStateError is raised with the message \"Only paid orders can be refunded\". It then validates that the refund_amount does not exceed the order's total_amount. If it does, an InvalidRefundAmountError is raised. The original payment transaction is retrieved by calling PaymentService.get_transaction() with the order's transaction_id. The refund is processed through the payment gateway by calling PaymentGateway.refund() with the original transaction and the refund amount, which returns a refund transaction object. If the refund fails (refund_transaction.success is False), a RefundFailedError is raised with the transaction's error message. If successful, the order's refund_amount is updated with the refund value, and the order status is set to 'refunded' if the refund equals the total amount, or 'partially_refunded' if it's a partial refund. The updated order is persisted by calling OrderService.update_order(). A refund record is created in the audit log by calling RefundLog.record() with the order ID, refund amount, reason, and refund transaction ID. A confirmation email is sent to the customer by calling EmailService.send_refund_confirmation() with the customer's email and refund amount. Finally, the function returns the refund transaction ID, allowing the calling code to track the refund operation."}
{"code": "def deploy_application(app_name, version, environment, config_overrides):\n    app_config = ConfigService.load_config(app_name, environment)\n    if config_overrides:\n        app_config = ConfigService.merge_configs(app_config, config_overrides)\n    validation_result = ConfigValidator.validate(app_config)\n    if not validation_result.is_valid:\n        raise ConfigurationError(f\"Invalid configuration: {validation_result.errors}\")\n    docker_image = f\"{app_name}:{version}\"\n    if not DockerRegistry.image_exists(docker_image):\n        raise ImageNotFoundError(f\"Docker image {docker_image} not found\")\n    existing_deployment = KubernetesAPI.get_deployment(app_name, environment)\n    if existing_deployment:\n        KubernetesAPI.update_deployment(existing_deployment, docker_image, app_config)\n    else:\n        KubernetesAPI.create_deployment(app_name, environment, docker_image, app_config)\n    health_check = HealthMonitor.wait_for_healthy(app_name, environment, timeout=300)\n    if not health_check.success:\n        KubernetesAPI.rollback_deployment(app_name, environment)\n        raise DeploymentFailedError(\"Health check failed, deployment rolled back\")\n    DeploymentLog.record(app_name, version, environment, 'success')\n    SlackNotifier.send_message(f\"Successfully deployed {app_name} v{version} to {environment}\")\n    return health_check.endpoint", "summary": "This function deploys an application to a specified environment by orchestrating configuration management, container deployment, and health monitoring through the following comprehensive workflow: First, it loads the base application configuration by calling ConfigService.load_config() with the app_name and environment. If any config_overrides are provided, the base configuration is merged with the overrides by calling ConfigService.merge_configs(). The merged configuration is validated by calling ConfigValidator.validate(), which returns a validation result object. If the configuration is invalid (validation_result.is_valid is False), a ConfigurationError is raised with details of the validation errors. A Docker image tag is constructed using the format \"app_name:version\". The function verifies that this Docker image exists in the registry by calling DockerRegistry.image_exists(). If the image is not found, an ImageNotFoundError is raised. The function checks for an existing deployment by calling KubernetesAPI.get_deployment() with the app_name and environment. If an existing deployment is found, it is updated with the new Docker image and configuration by calling KubernetesAPI.update_deployment(). If no existing deployment exists, a new deployment is created by calling KubernetesAPI.create_deployment() with the app name, environment, Docker image, and configuration. After deployment, the function waits for the application to become healthy by calling HealthMonitor.wait_for_healthy() with a 300-second timeout. If the health check fails (health_check.success is False), the deployment is rolled back by calling KubernetesAPI.rollback_deployment(), and a DeploymentFailedError is raised with the message \"Health check failed, deployment rolled back\". If the deployment succeeds, a deployment record is created by calling DeploymentLog.record() with the app name, version, environment, and 'success' status. A success notification is sent to Slack by calling SlackNotifier.send_message() with a formatted deployment message. Finally, the function returns the health check endpoint URL, allowing the calling code to verify or access the deployed application."}
{"code": "def analyze_sentiment(text, language, include_entities):\n    if not text or len(text.strip()) == 0:\n        raise ValueError(\"Text cannot be empty\")\n    detected_lang = LanguageDetector.detect(text)\n    if language and detected_lang != language:\n        logger.warning(f\"Detected language {detected_lang} differs from specified {language}\")\n    preprocessed = TextPreprocessor.clean(text)\n    tokens = Tokenizer.tokenize(preprocessed, detected_lang)\n    sentiment_score = SentimentModel.predict(tokens)\n    sentiment_label = SentimentClassifier.classify(sentiment_score)\n    result = {'score': sentiment_score, 'label': sentiment_label, 'language': detected_lang}\n    if include_entities:\n        entities = EntityExtractor.extract(tokens, detected_lang)\n        result['entities'] = entities\n    AnalyticsService.track_request('sentiment_analysis', detected_lang)\n    return result", "summary": "This function performs sentiment analysis on text input with optional entity extraction through the following process: First, it validates that the input text is not empty or whitespace-only by checking the text parameter. If the text is empty, a ValueError is raised with the message \"Text cannot be empty\". The function detects the language of the text by calling LanguageDetector.detect(). If a specific language was provided as a parameter and it differs from the detected language, a warning is logged using logger.warning() to alert about the mismatch. The text is preprocessed to remove noise and normalize formatting by calling TextPreprocessor.clean(). The cleaned text is tokenized into individual units by calling Tokenizer.tokenize() with the preprocessed text and detected language. A numerical sentiment score is computed by calling SentimentModel.predict() with the tokens. This score is converted into a categorical label (such as 'positive', 'negative', or 'neutral') by calling SentimentClassifier.classify(). A result dictionary is constructed containing the sentiment score, label, and detected language. If the include_entities parameter is True, named entities are extracted from the tokens by calling EntityExtractor.extract() with the tokens and detected language, and the extracted entities are added to the result dictionary under the 'entities' key. The function tracks the analysis request for analytics purposes by calling AnalyticsService.track_request() with the operation type 'sentiment_analysis' and the detected language. Finally, the function returns the result dictionary containing all the analysis results, allowing the calling code to access sentiment information and optionally entity data."}
