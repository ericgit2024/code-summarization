{"code": "def settext(self, text, cls='current'):\n        \"\"\"Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.\n        \"\"\"\n        self.replace(TextContent, value=text, cls=cls)", "summary": "Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.", "name": "settext", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L1357-L1364", "code_lines": 7, "summary_length": 288}
{"code": "def setdocument(self, doc):\n        \"\"\"Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.\n        \"\"\"\n        assert isinstance(doc, Document)\n\n        if not self.doc:\n            self.doc = doc\n            if self.id:\n                if self.id in doc:\n                    raise DuplicateIDError(self.id)\n                else:\n                    self.doc.index[id] = self\n\n        for e in self: #recursive for all children\n            if isinstance(e,AbstractElement): e.setdocument(doc)", "summary": "Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.", "name": "setdocument", "complexity": 6, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L1366-L1385", "code_lines": 16, "summary_length": 171}
{"code": "def addable(Class, parent, set=None, raiseexceptions=True):\n        \"\"\"Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError\n         \"\"\"\n\n\n        if not parent.__class__.accepts(Class, raiseexceptions, parent):\n            return False\n\n        if Class.OCCURRENCES > 0:\n            #check if the parent doesn't have too many already\n            count = parent.count(Class,None,True,[True, AbstractStructureElement]) #never descend into embedded structure annotatioton\n            if count >= Class.OCCURRENCES:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum.\")\n                else:\n                    return False\n\n        if Class.OCCURRENCES_PER_SET > 0 and set and Class.REQUIRED_ATTRIBS and Attrib.CLASS in Class.REQUIRED_ATTRIBS:\n            count = parent.count(Class,set,True, [True, AbstractStructureElement])\n            if count >= Class.OCCURRENCES_PER_SET:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of set \" + set + \" and type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum for the set.\")\n                else:\n                    return False\n\n\n\n        return True", "summary": "Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError", "name": "addable", "complexity": 13, "num_dependencies": 7, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L1406-L1455", "code_lines": 39, "summary_length": 539}
{"code": "def postappend(self):\n        \"\"\"This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.\n        \"\"\"\n\n        #If the element was not associated with a document yet, do so now (and for all unassociated children:\n        if not self.doc and self.parent.doc:\n            self.setdocument(self.parent.doc)\n\n        if self.doc and self.doc.deepvalidation:\n            self.deepvalidation()", "summary": "This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.", "name": "postappend", "complexity": 5, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L1458-L1471", "code_lines": 10, "summary_length": 277}
{"code": "def updatetext(self):\n        \"\"\"Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``\"\"\"\n        if self.TEXTCONTAINER:\n            s = \"\"\n            for child in self:\n                if isinstance(child, AbstractElement):\n                    child.updatetext()\n                    s += child.text()\n                elif isstring(child):\n                    s += child\n            self.data = [s]", "summary": "Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``", "name": "updatetext", "complexity": 5, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L1772-L1782", "code_lines": 11, "summary_length": 122}
{"code": "def ancestors(self, Class=None):\n        \"\"\"Generator yielding all ancestors of this element, effectively back-tracing its path to the root element. A tuple of multiple classes may be specified.\n\n        Arguments:\n            *Class: The class or classes (:class:`AbstractElement` or subclasses). Not instances!\n\n        Yields:\n            elements (instances derived from :class:`AbstractElement`)\n        \"\"\"\n        e = self\n        while e:\n            if e.parent:\n                e = e.parent\n                if not Class or isinstance(e,Class):\n                    yield e\n                elif isinstance(Class, tuple):\n                    for C in Class:\n                        if isinstance(e,C):\n                            yield e\n            else:\n                break", "summary": "Generator yielding all ancestors of this element, effectively back-tracing its path to the root element. A tuple of multiple classes may be specified.\n\n        Arguments:\n            *Class: The class or classes (:class:`AbstractElement` or subclasses). Not instances!\n\n        Yields:\n            elements (instances derived from :class:`AbstractElement`)", "name": "ancestors", "complexity": 8, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L1840-L1860", "code_lines": 19, "summary_length": 356}
{"code": "def ancestor(self, *Classes):\n        \"\"\"Find the most immediate ancestor of the specified type, multiple classes may be specified.\n\n        Arguments:\n            *Classes: The possible classes (:class:`AbstractElement` or subclasses) to select from. Not instances!\n\n        Example::\n\n            paragraph = word.ancestor(folia.Paragraph)\n        \"\"\"\n        for e in self.ancestors(tuple(Classes)):\n            return e\n        raise NoSuchAnnotation", "summary": "Find the most immediate ancestor of the specified type, multiple classes may be specified.\n\n        Arguments:\n            *Classes: The possible classes (:class:`AbstractElement` or subclasses) to select from. Not instances!\n\n        Example::\n\n            paragraph = word.ancestor(folia.Paragraph)", "name": "ancestor", "complexity": 2, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L1862-L1874", "code_lines": 10, "summary_length": 300}
{"code": "def json(self, attribs=None, recurse=True, ignorelist=False):\n        \"\"\"Serialises the FoLiA element and all its contents to a Python dictionary suitable for serialisation to JSON.\n\n        Example::\n\n            import json\n            json.dumps(word.json())\n\n        Returns:\n            dict\n        \"\"\"\n        jsonnode = {}\n\n        jsonnode['type'] = self.XMLTAG\n        if self.id:\n            jsonnode['id'] = self.id\n        if self.set:\n            jsonnode['set'] = self.set\n        if self.cls:\n            jsonnode['class'] = self.cls\n        if self.annotator:\n            jsonnode['annotator'] = self.annotator\n        if self.annotatortype:\n            if self.annotatortype == AnnotatorType.AUTO:\n                jsonnode['annotatortype'] = \"auto\"\n            elif self.annotatortype == AnnotatorType.MANUAL:\n                jsonnode['annotatortype'] = \"manual\"\n        if self.confidence is not None:\n            jsonnode['confidence'] = self.confidence\n        if self.n:\n            jsonnode['n'] = self.n\n        if self.auth:\n            jsonnode['auth'] = self.auth\n        if self.datetime:\n            jsonnode['datetime'] = self.datetime.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        if recurse: #pylint: disable=too-many-nested-blocks\n            jsonnode['children'] = []\n            if self.TEXTCONTAINER:\n                jsonnode['text'] = self.text()\n            if self.PHONCONTAINER:\n                jsonnode['phon'] = self.phon()\n            for child in self:\n                if self.TEXTCONTAINER and isstring(child):\n                    jsonnode['children'].append(child)\n                elif not self.PHONCONTAINER:\n                    #check ignore list\n                    ignore = False\n                    if ignorelist:\n                        for e in ignorelist:\n                            if isinstance(child,e):\n                                ignore = True\n                                break\n                    if not ignore:\n                        jsonnode['children'].append(child.json(attribs,recurse,ignorelist))\n\n        if attribs:\n            for attrib in attribs:\n                jsonnode[attrib] = attribs\n\n        return jsonnode", "summary": "Serialises the FoLiA element and all its contents to a Python dictionary suitable for serialisation to JSON.\n\n        Example::\n\n            import json\n            json.dumps(word.json())\n\n        Returns:\n            dict", "name": "json", "complexity": 25, "num_dependencies": 8, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2050-L2110", "code_lines": 54, "summary_length": 223}
{"code": "def xmlstring(self, pretty_print=False):\n        \"\"\"Serialises this FoLiA element and all its contents to XML.\n\n        Returns:\n            str: a string with XML representation for this element and all its children\"\"\"\n        s = ElementTree.tostring(self.xml(), xml_declaration=False, pretty_print=pretty_print, encoding='utf-8')\n        if sys.version < '3':\n            if isinstance(s, str):\n                s = unicode(s,'utf-8') #pylint: disable=undefined-variable\n        else:\n            if isinstance(s,bytes):\n                s = str(s,'utf-8')\n\n        s = s.replace('ns0:','') #ugly patch to get rid of namespace prefix\n        s = s.replace(':ns0','')\n        return s", "summary": "Serialises this FoLiA element and all its contents to XML.\n\n        Returns:\n            str: a string with XML representation for this element and all its children", "name": "xmlstring", "complexity": 4, "num_dependencies": 8, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2114-L2129", "code_lines": 14, "summary_length": 164}
{"code": "def select(self, Class, set=None, recursive=True,  ignore=True, node=None): #pylint: disable=bad-classmethod-argument,redefined-builtin\n        \"\"\"Select child elements of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n            recursive (bool): Select recursively? Descending into child elements? Defaults to ``True``.\n            ignore: A list of Classes to ignore, if set to ``True`` instead of a list, all non-authoritative elements will be skipped (this is the default behaviour and corresponds to the following elements: :class:`Alternative`, :class:`AlternativeLayer`, :class:`Suggestion`, and :class:`folia.Original`. These elements and those contained within are never *authorative*. You may also include the boolean True as a member of a list, if you want to skip additional tags along the predefined non-authoritative ones.\n            * ``node``: Reserved for internal usage, used in recursion.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.select(folia.Sense, 'cornetto', True, [folia.Original, folia.Suggestion, folia.Alternative] ):\n                ..\n\n        \"\"\"\n\n        #if ignorelist is True:\n        #    ignorelist = default_ignore\n\n        if not node:\n            node = self\n        for e in self.data: #pylint: disable=too-many-nested-blocks\n            if (not self.TEXTCONTAINER and not self.PHONCONTAINER) or isinstance(e, AbstractElement):\n                if ignore is True:\n                    try:\n                        if not e.auth:\n                            continue\n                    except AttributeError:\n                        #not all elements have auth attribute..\n                        pass\n                elif ignore: #list\n                    doignore = False\n                    for c in ignore:\n                        if c is True:\n                            try:\n                                if not e.auth:\n                                    doignore =True\n                                    break\n                            except AttributeError:\n                                #not all elements have auth attribute..\n                                pass\n                        elif c == e.__class__ or issubclass(e.__class__,c):\n                            doignore = True\n                            break\n                    if doignore:\n                        continue\n\n                if isinstance(e, Class):\n                    if not set is None:\n                        try:\n                            if e.set != set:\n                                continue\n                        except AttributeError:\n                            continue\n                    yield e\n                if recursive:\n                    for e2 in e.select(Class, set, recursive, ignore, e):\n                        if not set is None:\n                            try:\n                                if e2.set != set:\n                                    continue\n                            except AttributeError:\n                                continue\n                        yield e2", "summary": "Select child elements of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n            recursive (bool): Select recursively? Descending into child elements? Defaults to ``True``.\n            ignore: A list of Classes to ignore, if set to ``True`` instead of a list, all non-authoritative elements will be skipped (this is the default behaviour and corresponds to the following elements: :class:`Alternative`, :class:`AlternativeLayer`, :class:`Suggestion`, and :class:`folia.Original`. These elements and those contained within are never *authorative*. You may also include the boolean True as a member of a list, if you want to skip additional tags along the predefined non-authoritative ones.\n            * ``node``: Reserved for internal usage, used in recursion.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.select(folia.Sense, 'cornetto', True, [folia.Original, folia.Suggestion, folia.Alternative] ):\n                ..", "name": "select", "complexity": 26, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2132-L2201", "code_lines": 61, "summary_length": 1365}
{"code": "def getmetadata(self, key=None):\n        \"\"\"Get the metadata that applies to this element, automatically inherited from parent elements\"\"\"\n        if self.metadata:\n            d =  self.doc.submetadata[self.metadata]\n        elif self.parent:\n            d =  self.parent.getmetadata()\n        elif self.doc:\n            d =  self.doc.metadata\n        else:\n            return None\n        if key:\n            return d[key]\n        else:\n            return d", "summary": "Get the metadata that applies to this element, automatically inherited from parent elements", "name": "getmetadata", "complexity": 5, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2221-L2234", "code_lines": 14, "summary_length": 91}
{"code": "def getindex(self, child, recursive=True, ignore=True):\n        \"\"\"Get the index at which an element occurs, recursive by default!\n\n        Returns:\n            int\n        \"\"\"\n\n        #breadth first search\n        for i, c in enumerate(self.data):\n            if c is child:\n                return i\n        if recursive:  #pylint: disable=too-many-nested-blocks\n            for i, c in enumerate(self.data):\n                if ignore is True:\n                    try:\n                        if not c.auth:\n                            continue\n                    except AttributeError:\n                        #not all elements have auth attribute..\n                        pass\n                elif ignore: #list\n                    doignore = False\n                    for e in ignore:\n                        if e is True:\n                            try:\n                                if not c.auth:\n                                    doignore =True\n                                    break\n                            except AttributeError:\n                                #not all elements have auth attribute..\n                                pass\n                        elif e == c.__class__ or issubclass(c.__class__,e):\n                            doignore = True\n                            break\n                    if doignore:\n                        continue\n                if isinstance(c, AbstractElement):\n                    j = c.getindex(child, recursive)\n                    if j != -1:\n                        return i #yes, i ... not j!\n        return -1", "summary": "Get the index at which an element occurs, recursive by default!\n\n        Returns:\n            int", "name": "getindex", "complexity": 18, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2238-L2278", "code_lines": 39, "summary_length": 97}
{"code": "def precedes(self, other):\n        \"\"\"Returns a boolean indicating whether this element precedes the other element\"\"\"\n        try:\n            ancestor = next(commonancestors(AbstractElement, self, other))\n        except StopIteration:\n            raise Exception(\"Elements share no common ancestor\")\n        #now we just do a depth first search and see who comes first\n        def callback(e):\n            if e is self:\n                return True\n            elif e is other:\n                return False\n            return None\n        result = ancestor.depthfirstsearch(callback)\n        if result is None:\n            raise Exception(\"Unable to find relation between elements! (shouldn't happen)\")\n        return result", "summary": "Returns a boolean indicating whether this element precedes the other element", "name": "precedes", "complexity": 5, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2280-L2296", "code_lines": 17, "summary_length": 76}
{"code": "def depthfirstsearch(self, function):\n        \"\"\"Generic depth first search algorithm using a callback function, continues as long as the callback function returns None\"\"\"\n        result = function(self)\n        if result is not None:\n            return result\n        for e in self:\n            result = e.depthfirstsearch(function)\n            if result is not None:\n                return result\n        return None", "summary": "Generic depth first search algorithm using a callback function, continues as long as the callback function returns None", "name": "depthfirstsearch", "complexity": 4, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2299-L2308", "code_lines": 10, "summary_length": 119}
{"code": "def next(self, Class=True, scope=True, reverse=False):\n        \"\"\"Returns the next element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``, may also be a tuple of multiple classes. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.\n\n        \"\"\"\n        if Class is True: Class = self.__class__\n        if scope is True: scope = STRUCTURESCOPE\n\n        structural = Class is not None and issubclass(Class,AbstractStructureElement)\n\n        if reverse:\n            order = reversed\n            descendindex = -1\n        else:\n            order = lambda x: x #pylint: disable=redefined-variable-type\n            descendindex = 0\n\n        child = self\n        parent = self.parent\n        while parent: #pylint: disable=too-many-nested-blocks\n            if len(parent) > 1:\n                returnnext = False\n                for e in order(parent):\n                    if e is child:\n                        #we found the current item, next item will be the one to return\n                        returnnext = True\n                    elif returnnext and e.auth and not isinstance(e,AbstractAnnotationLayer) and (not structural or (structural and (not isinstance(e,(AbstractTokenAnnotation,TextContent)) ) )):\n                        if structural and isinstance(e,Correction):\n                            if not list(e.select(AbstractStructureElement)): #skip-over non-structural correction\n                                continue\n\n                        if Class is None or (isinstance(Class,tuple) and (any(isinstance(e,C) for C in Class))) or isinstance(e,Class):\n                            return e\n                        else:\n                            #this is not yet the element of the type we are looking for, we are going to descend again in the very leftmost (rightmost if reversed) branch only\n                            while e.data:\n                                e = e.data[descendindex]\n                                if not isinstance(e, AbstractElement):\n                                    return None #we've gone too far\n                                if e.auth and not isinstance(e,AbstractAnnotationLayer):\n                                    if Class is None or (isinstance(Class,tuple) and (any(isinstance(e,C) for C in Class))) or isinstance(e,Class):\n                                        return e\n                                    else:\n                                        #descend deeper\n                                        continue\n                        return None\n\n            #generational iteration\n            child = parent\n            if scope is not None and child.__class__ in scope:\n                #you shall not pass!\n                break\n            parent = parent.parent\n\n        return None", "summary": "Returns the next element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``, may also be a tuple of multiple classes. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.", "name": "next", "complexity": 32, "num_dependencies": 18, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2310-L2367", "code_lines": 50, "summary_length": 745}
{"code": "def previous(self, Class=True, scope=True):\n        \"\"\"Returns the previous element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.\n\n        \"\"\"\n        return self.next(Class,scope, True)", "summary": "Returns the previous element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.", "name": "previous", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2371-L2379", "code_lines": 7, "summary_length": 708}
{"code": "def remove(self, child):\n        \"\"\"Removes the child element\"\"\"\n        if not isinstance(child, AbstractElement):\n            raise ValueError(\"Expected AbstractElement, got \" + str(type(child)))\n        if child.parent == self:\n            child.parent = None\n        self.data.remove(child)\n        #delete from index\n        if child.id and self.doc and child.id in self.doc.index:\n            del self.doc.index[child.id]", "summary": "Removes the child element", "name": "remove", "complexity": 6, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L2729-L2738", "code_lines": 10, "summary_length": 25}
{"code": "def hasannotation(self,Class,set=None):\n        \"\"\"Returns an integer indicating whether such as annotation exists, and if so, how many.\n\n        See :meth:`AllowTokenAnnotation.annotations`` for a description of the parameters.\"\"\"\n        return sum( 1 for _ in self.select(Class,set,True,default_ignore_annotations))", "summary": "Returns an integer indicating whether such as annotation exists, and if so, how many.\n\n        See :meth:`AllowTokenAnnotation.annotations`` for a description of the parameters.", "name": "hasannotation", "complexity": 1, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L3046-L3050", "code_lines": 4, "summary_length": 177}
{"code": "def annotation(self, type, set=None):\n        \"\"\"Obtain a single annotation element.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Returns:\n            An element (instance derived from :class:`AbstractElement`)\n\n        Example::\n\n            sense = word.annotation(folia.Sense, 'http://some/path/cornetto').cls\n\n        See also:\n            :meth:`AllowTokenAnnotation.annotations`\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :class:`NoSuchAnnotation` if no such annotation exists\n        \"\"\"\n        \"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"\n        for e in self.select(type,set,True,default_ignore_annotations):\n            return e\n        raise NoSuchAnnotation()", "summary": "Obtain a single annotation element.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Returns:\n            An element (instance derived from :class:`AbstractElement`)\n\n        Example::\n\n            sense = word.annotation(folia.Sense, 'http://some/path/cornetto').cls\n\n        See also:\n            :meth:`AllowTokenAnnotation.annotations`\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :class:`NoSuchAnnotation` if no such annotation exists", "name": "annotation", "complexity": 2, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L3052-L3078", "code_lines": 20, "summary_length": 802}
{"code": "def hasannotationlayer(self, annotationtype=None,set=None):\n        \"\"\"Does the specified annotation layer exist?\"\"\"\n        l = self.layers(annotationtype, set)\n        return (len(l) > 0)", "summary": "Does the specified annotation layer exist?", "name": "hasannotationlayer", "complexity": 1, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L3268-L3271", "code_lines": 4, "summary_length": 42}
{"code": "def getreference(self, validate=True):\n        \"\"\"Returns and validates the Text Content's reference. Raises UnresolvableTextContent when invalid\"\"\"\n\n        if self.offset is None: return None #nothing to test\n        if self.ref:\n            ref = self.doc[self.ref]\n        else:\n            ref = self.finddefaultreference()\n\n        if not ref:\n            raise UnresolvableTextContent(\"Default reference for textcontent not found!\")\n        elif not ref.hastext(self.cls):\n            raise UnresolvableTextContent(\"Reference (ID \" + str(ref.id) + \") has no such text (class=\" + self.cls+\")\")\n        elif validate and self.text() != ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])]:\n            raise UnresolvableTextContent(\"Reference (ID \" + str(ref.id) + \", class=\" + self.cls+\") found but no text match at specified offset (\"+str(self.offset)+\")! Expected '\" + self.text() + \"', got '\" + ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])] +\"'\")\n        else:\n            #finally, we made it!\n            return ref", "summary": "Returns and validates the Text Content's reference. Raises UnresolvableTextContent when invalid", "name": "getreference", "complexity": 7, "num_dependencies": 14, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L3502-L3519", "code_lines": 16, "summary_length": 95}
{"code": "def getreference(self, validate=True):\n        \"\"\"Return and validate the Phonetic Content's reference. Raises UnresolvableTextContent when invalid\"\"\"\n\n        if self.offset is None: return None #nothing to test\n        if self.ref:\n            ref = self.doc[self.ref]\n        else:\n            ref = self.finddefaultreference()\n\n        if not ref:\n            raise UnresolvableTextContent(\"Default reference for phonetic content not found!\")\n        elif not ref.hasphon(self.cls):\n            raise UnresolvableTextContent(\"Reference has no such phonetic content (class=\" + self.cls+\")\")\n        elif validate and self.phon() != ref.textcontent(self.cls).phon()[self.offset:self.offset+len(self.data[0])]:\n            raise UnresolvableTextContent(\"Reference (class=\" + self.cls+\") found but no phonetic match at specified offset (\"+str(self.offset)+\")! Expected '\" + self.text() + \"', got '\" + ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])] +\"'\")\n        else:\n            #finally, we made it!\n            return ref", "summary": "Return and validate the Phonetic Content's reference. Raises UnresolvableTextContent when invalid", "name": "getreference", "complexity": 7, "num_dependencies": 12, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L3715-L3732", "code_lines": 16, "summary_length": 97}
{"code": "def findspans(self, type,set=None):\n        \"\"\"Yields span annotation elements of the specified type that include this word.\n\n        Arguments:\n            type: The annotation type, can be passed as using any of the :class:`AnnotationType` member, or by passing the relevant :class:`AbstractSpanAnnotation` or :class:`AbstractAnnotationLayer` class.\n            set (str or None): Constrain by set\n\n        Example::\n\n            for chunk in word.findspans(folia.Chunk):\n                print(\" Chunk class=\", chunk.cls, \" words=\")\n                for word2 in chunk.wrefs(): #print all words in the chunk (of which the word is a part)\n                    print(word2, end=\"\")\n                print()\n\n        Yields:\n            Matching span annotation instances (derived from :class:`AbstractSpanAnnotation`)\n        \"\"\"\n\n        if issubclass(type, AbstractAnnotationLayer):\n            layerclass = type\n        else:\n            layerclass = ANNOTATIONTYPE2LAYERCLASS[type.ANNOTATIONTYPE]\n        e = self\n        while True:\n            if not e.parent: break\n            e = e.parent\n            for layer in e.select(layerclass,set,False):\n                if type is layerclass:\n                    for e2 in layer.select(AbstractSpanAnnotation,set,True, (True, Word, Morpheme)):\n                        if not isinstance(e2, AbstractSpanRole) and self in e2.wrefs():\n                            yield e2\n                else:\n                    for e2 in layer.select(type,set,True, (True, Word, Morpheme)):\n                        if not isinstance(e2, AbstractSpanRole) and self in e2.wrefs():\n                            yield e2", "summary": "Yields span annotation elements of the specified type that include this word.\n\n        Arguments:\n            type: The annotation type, can be passed as using any of the :class:`AnnotationType` member, or by passing the relevant :class:`AbstractSpanAnnotation` or :class:`AbstractAnnotationLayer` class.\n            set (str or None): Constrain by set\n\n        Example::\n\n            for chunk in word.findspans(folia.Chunk):\n                print(\" Chunk class=\", chunk.cls, \" words=\")\n                for word2 in chunk.wrefs(): #print all words in the chunk (of which the word is a part)\n                    print(word2, end=\"\")\n                print()\n\n        Yields:\n            Matching span annotation instances (derived from :class:`AbstractSpanAnnotation`)", "name": "findspans", "complexity": 12, "num_dependencies": 8, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4178-L4213", "code_lines": 31, "summary_length": 767}
{"code": "def setspan(self, *args):\n        \"\"\"Sets the span of the span element anew, erases all data inside.\n\n        Arguments:\n            *args: Instances of :class:`Word`, :class:`Morpheme` or :class:`Phoneme`\n        \"\"\"\n        self.data = []\n        for child in args:\n            self.append(child)", "summary": "Sets the span of the span element anew, erases all data inside.\n\n        Arguments:\n            *args: Instances of :class:`Word`, :class:`Morpheme` or :class:`Phoneme`", "name": "setspan", "complexity": 2, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4373-L4381", "code_lines": 8, "summary_length": 168}
{"code": "def _helper_wrefs(self, targets, recurse=True):\n        \"\"\"Internal helper function\"\"\"\n        for c in self:\n            if isinstance(c,Word) or isinstance(c,Morpheme) or isinstance(c, Phoneme):\n                targets.append(c)\n            elif isinstance(c,WordReference):\n                try:\n                    targets.append(self.doc[c.id]) #try to resolve\n                except KeyError:\n                    targets.append(c) #add unresolved\n            elif isinstance(c, AbstractSpanAnnotation) and recurse:\n                #recursion\n                c._helper_wrefs(targets) #pylint: disable=protected-access\n            elif isinstance(c, Correction) and c.auth: #recurse into corrections\n                for e in c:\n                    if isinstance(e, AbstractCorrectionChild) and e.auth:\n                        for e2 in e:\n                            if isinstance(e2, AbstractSpanAnnotation):\n                                #recursion\n                                e2._helper_wrefs(targets)", "summary": "Internal helper function", "name": "_helper_wrefs", "complexity": 16, "num_dependencies": 13, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4418-L4437", "code_lines": 20, "summary_length": 24}
{"code": "def wrefs(self, index = None, recurse=True):\n        \"\"\"Returns a list of word references, these can be Words but also Morphemes or Phonemes.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all\n        \"\"\"\n        targets =[]\n        self._helper_wrefs(targets, recurse)\n        if index is None:\n            return targets\n        else:\n            return targets[index]", "summary": "Returns a list of word references, these can be Words but also Morphemes or Phonemes.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all", "name": "wrefs", "complexity": 2, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4439-L4450", "code_lines": 11, "summary_length": 255}
{"code": "def copychildren(self, newdoc=None, idsuffix=\"\"):\n        \"\"\"Generator creating a deep copy of the children of this element. If idsuffix is a string, if set to True, a random idsuffix will be generated including a random 32-bit hash\"\"\"\n        if idsuffix is True: idsuffix = \".copy.\" + \"%08x\" % random.getrandbits(32) #random 32-bit hash for each copy, same one will be reused for all children\n        for c in self:\n            if isinstance(c, Word):\n                yield WordReference(newdoc, id=c.id)\n            else:\n                yield c.copy(newdoc,idsuffix)", "summary": "Generator creating a deep copy of the children of this element. If idsuffix is a string, if set to True, a random idsuffix will be generated including a random 32-bit hash", "name": "copychildren", "complexity": 4, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4465-L4472", "code_lines": 8, "summary_length": 171}
{"code": "def alternatives(self, Class=None, set=None):\n        \"\"\"Generator over alternatives, either all or only of a specific annotation type, and possibly restrained also by set.\n\n        Arguments:\n            * ``Class`` - The Class you want to retrieve (e.g. PosAnnotation). Or set to None to select all alternatives regardless of what type they are.\n            * ``set``   - The set you want to retrieve (defaults to None, which selects irregardless of set)\n\n        Returns:\n            Generator over Alternative elements\n        \"\"\"\n\n        for e in self.select(AlternativeLayers,None, True, ['Original','Suggestion']): #pylint: disable=too-many-nested-blocks\n            if Class is None:\n                yield e\n            elif len(e) >= 1: #child elements?\n                for e2 in e:\n                    try:\n                        if isinstance(e2, Class):\n                            try:\n                                if set is None or e2.set == set:\n                                    yield e #not e2\n                                    break #yield an alternative only once (in case there are multiple matches)\n                            except AttributeError:\n                                continue\n                    except AttributeError:\n                        continue", "summary": "Generator over alternatives, either all or only of a specific annotation type, and possibly restrained also by set.\n\n        Arguments:\n            * ``Class`` - The Class you want to retrieve (e.g. PosAnnotation). Or set to None to select all alternatives regardless of what type they are.\n            * ``set``   - The set you want to retrieve (defaults to None, which selects irregardless of set)\n\n        Returns:\n            Generator over Alternative elements", "name": "alternatives", "complexity": 10, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4574-L4599", "code_lines": 23, "summary_length": 465}
{"code": "def findspan(self, *words):\n        \"\"\"Returns the span element which spans over the specified words or morphemes.\n\n        See also:\n            :meth:`Word.findspans`\n        \"\"\"\n\n        for span in self.select(AbstractSpanAnnotation,None,True):\n            if tuple(span.wrefs()) == words:\n                return span\n        raise NoSuchAnnotation", "summary": "Returns the span element which spans over the specified words or morphemes.\n\n        See also:\n            :meth:`Word.findspans`", "name": "findspan", "complexity": 3, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4601-L4611", "code_lines": 9, "summary_length": 129}
{"code": "def hasnew(self,allowempty=False):\n        \"\"\"Does the correction define new corrected annotations?\"\"\"\n        for e in  self.select(New,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False", "summary": "Does the correction define new corrected annotations?", "name": "hasnew", "complexity": 4, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4982-L4987", "code_lines": 6, "summary_length": 53}
{"code": "def hasoriginal(self,allowempty=False):\n        \"\"\"Does the correction record the old annotations prior to correction?\"\"\"\n        for e in self.select(Original,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False", "summary": "Does the correction record the old annotations prior to correction?", "name": "hasoriginal", "complexity": 4, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L4989-L4994", "code_lines": 6, "summary_length": 67}
{"code": "def hassuggestions(self,allowempty=False):\n        \"\"\"Does the correction propose suggestions for correction?\"\"\"\n        for e in self.select(Suggestion,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False", "summary": "Does the correction propose suggestions for correction?", "name": "hassuggestions", "complexity": 4, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L5003-L5008", "code_lines": 6, "summary_length": 55}
{"code": "def new(self,index = None):\n        \"\"\"Get the new corrected annotation.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n\n        if index is None:\n            try:\n                return next(self.select(New,None,False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(New,None,False):\n                return e[index]\n            raise NoSuchAnnotation", "summary": "Get the new corrected annotation.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`", "name": "new", "complexity": 4, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L5106-L5126", "code_lines": 17, "summary_length": 275}
{"code": "def original(self,index=None):\n        \"\"\"Get the old annotation prior to correction.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n        if index is None:\n            try:\n                return next(self.select(Original,None,False, False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(Original,None,False, False):\n                return e[index]\n            raise NoSuchAnnotation", "summary": "Get the old annotation prior to correction.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`", "name": "original", "complexity": 4, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L5128-L5147", "code_lines": 17, "summary_length": 285}
{"code": "def suggestions(self,index=None):\n        \"\"\"Get suggestions for correction.\n\n        Yields:\n            :class:`Suggestion` element that encapsulate the suggested annotations (if index is ``None``, default)\n\n        Returns:\n            a :class:`Suggestion` element that encapsulate the suggested annotations (if index is set)\n\n        Raises:\n            :class:`IndexError`\n        \"\"\"\n        if index is None:\n            return self.select(Suggestion,None,False, False)\n        else:\n            for i, e in enumerate(self.select(Suggestion,None,False, False)):\n                if index == i:\n                    return e\n            raise IndexError", "summary": "Get suggestions for correction.\n\n        Yields:\n            :class:`Suggestion` element that encapsulate the suggested annotations (if index is ``None``, default)\n\n        Returns:\n            a :class:`Suggestion` element that encapsulate the suggested annotations (if index is set)\n\n        Raises:\n            :class:`IndexError`", "name": "suggestions", "complexity": 4, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L5170-L5188", "code_lines": 16, "summary_length": 333}
{"code": "def findspans(self, type,set=None):\n        \"\"\"Find span annotation of the specified type that include this word\"\"\"\n        if issubclass(type, AbstractAnnotationLayer):\n            layerclass = type\n        else:\n            layerclass = ANNOTATIONTYPE2LAYERCLASS[type.ANNOTATIONTYPE]\n        e = self\n        while True:\n            if not e.parent: break\n            e = e.parent\n            for layer in e.select(layerclass,set,False):\n                for e2 in layer:\n                    if isinstance(e2, AbstractSpanAnnotation):\n                        if self in e2.wrefs():\n                            yield e2", "summary": "Find span annotation of the specified type that include this word", "name": "findspans", "complexity": 8, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L5528-L5542", "code_lines": 15, "summary_length": 65}
{"code": "def resolve(self,size, distribution):\n        \"\"\"Resolve a variable sized pattern to all patterns of a certain fixed size\"\"\"\n        if not self.variablesize():\n            raise Exception(\"Can only resize patterns with * wildcards\")\n\n        nrofwildcards = 0\n        for x in self.sequence:\n            if x == '*':\n                nrofwildcards += 1\n\n        assert (len(distribution) == nrofwildcards)\n\n        wildcardnr = 0\n        newsequence = []\n        for x in self.sequence:\n            if x == '*':\n                newsequence += [True] * distribution[wildcardnr]\n                wildcardnr += 1\n            else:\n                newsequence.append(x)\n        d = { 'matchannotation':self.matchannotation, 'matchannotationset':self.matchannotationset, 'casesensitive':self.casesensitive }\n        yield Pattern(*newsequence, **d )", "summary": "Resolve a variable sized pattern to all patterns of a certain fixed size", "name": "resolve", "complexity": 6, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6221-L6242", "code_lines": 19, "summary_length": 72}
{"code": "def load(self, filename):\n        \"\"\"Load a FoLiA XML file.\n\n        Argument:\n            filename (str): The file to load\n        \"\"\"\n        #if LXE and self.mode != Mode.XPATH:\n        #    #workaround for xml:id problem (disabled)\n        #    #f = open(filename)\n        #    #s = f.read().replace(' xml:id=', ' id=')\n        #    #f.close()\n        #    self.tree = ElementTree.parse(filename)\n        #else:\n        self.tree = xmltreefromfile(filename)\n        self.parsexml(self.tree.getroot())\n        if self.mode != Mode.XPATH:\n            #XML Tree is now obsolete (only needed when partially loaded for xpath queries)\n            self.tree = None", "summary": "Load a FoLiA XML file.\n\n        Argument:\n            filename (str): The file to load", "name": "load", "complexity": 2, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6495-L6512", "code_lines": 17, "summary_length": 86}
{"code": "def items(self):\n        \"\"\"Returns a depth-first flat list of all items in the document\"\"\"\n        l = []\n        for e in self.data:\n            l += e.items()\n        return l", "summary": "Returns a depth-first flat list of all items in the document", "name": "items", "complexity": 2, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6514-L6519", "code_lines": 6, "summary_length": 60}
{"code": "def save(self, filename=None):\n        \"\"\"Save the document to file.\n\n        Arguments:\n            * filename (str): The filename to save to. If not set (``None``, default), saves to the same file as loaded from.\n        \"\"\"\n        if not filename:\n            filename = self.filename\n        if not filename:\n            raise Exception(\"No filename specified\")\n        if filename[-4:].lower() == '.bz2':\n            f = bz2.BZ2File(filename,'wb')\n            f.write(self.xmlstring().encode('utf-8'))\n            f.close()\n        elif filename[-3:].lower() == '.gz':\n            f = gzip.GzipFile(filename,'wb') #pylint: disable=redefined-variable-type\n            f.write(self.xmlstring().encode('utf-8'))\n            f.close()\n        else:\n            f = io.open(filename,'w',encoding='utf-8')\n            f.write(self.xmlstring())\n            f.close()", "summary": "Save the document to file.\n\n        Arguments:\n            * filename (str): The filename to save to. If not set (``None``, default), saves to the same file as loaded from.", "name": "save", "complexity": 5, "num_dependencies": 15, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6547-L6568", "code_lines": 21, "summary_length": 172}
{"code": "def xmldeclarations(self):\n        \"\"\"Internal method to generate XML nodes for all declarations\"\"\"\n        l = []\n        E = ElementMaker(namespace=\"http://ilk.uvt.nl/folia\",nsmap={None: \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n\n        for annotationtype, set in self.annotations:\n            label = None\n            #Find the 'label' for the declarations dynamically (aka: AnnotationType --> String)\n            for key, value in vars(AnnotationType).items():\n                if value == annotationtype:\n                    label = key\n                    break\n            #gather attribs\n\n            if (annotationtype == AnnotationType.TEXT or annotationtype == AnnotationType.PHON) and set == 'undefined' and len(self.annotationdefaults[annotationtype][set]) == 0:\n                #this is the implicit TextContent declaration, no need to output it explicitly\n                continue\n\n            attribs = {}\n            if set and set != 'undefined':\n                attribs['{' + NSFOLIA + '}set'] = set\n\n\n            for key, value in self.annotationdefaults[annotationtype][set].items():\n                if key == 'annotatortype':\n                    if value == AnnotatorType.MANUAL:\n                        attribs['{' + NSFOLIA + '}' + key] = 'manual'\n                    elif value == AnnotatorType.AUTO:\n                        attribs['{' + NSFOLIA + '}' + key] = 'auto'\n                elif key == 'datetime':\n                    attribs['{' + NSFOLIA + '}' + key] = value.strftime(\"%Y-%m-%dT%H:%M:%S\") #proper iso-formatting\n                elif value:\n                    attribs['{' + NSFOLIA + '}' + key] = value\n            if label:\n                l.append( makeelement(E,'{' + NSFOLIA + '}' + label.lower() + '-annotation', **attribs) )\n            else:\n                raise Exception(\"Invalid annotation type\")\n        return l", "summary": "Internal method to generate XML nodes for all declarations", "name": "xmldeclarations", "complexity": 17, "num_dependencies": 9, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6653-L6690", "code_lines": 33, "summary_length": 58}
{"code": "def jsondeclarations(self):\n        \"\"\"Return all declarations in a form ready to be serialised to JSON.\n\n        Returns:\n            list of dict\n        \"\"\"\n        l = []\n        for annotationtype, set in self.annotations:\n            label = None\n            #Find the 'label' for the declarations dynamically (aka: AnnotationType --> String)\n            for key, value in vars(AnnotationType).items():\n                if value == annotationtype:\n                    label = key\n                    break\n            #gather attribs\n\n            if (annotationtype == AnnotationType.TEXT or annotationtype == AnnotationType.PHON) and set == 'undefined' and len(self.annotationdefaults[annotationtype][set]) == 0:\n                #this is the implicit TextContent declaration, no need to output it explicitly\n                continue\n\n            jsonnode = {'annotationtype': label.lower()}\n            if set and set != 'undefined':\n                jsonnode['set'] = set\n\n\n            for key, value in self.annotationdefaults[annotationtype][set].items():\n                if key == 'annotatortype':\n                    if value == AnnotatorType.MANUAL:\n                        jsonnode[key] = 'manual'\n                    elif value == AnnotatorType.AUTO:\n                        jsonnode[key] = 'auto'\n                elif key == 'datetime':\n                    jsonnode[key] = value.strftime(\"%Y-%m-%dT%H:%M:%S\") #proper iso-formatting\n                elif value:\n                    jsonnode[key] = value\n            if label:\n                l.append( jsonnode  )\n            else:\n                raise Exception(\"Invalid annotation type\")\n        return l", "summary": "Return all declarations in a form ready to be serialised to JSON.\n\n        Returns:\n            list of dict", "name": "jsondeclarations", "complexity": 17, "num_dependencies": 7, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6692-L6731", "code_lines": 35, "summary_length": 108}
{"code": "def xml(self):\n        \"\"\"Serialise the document to XML.\n\n        Returns:\n            lxml.etree.Element\n\n        See also:\n            :meth:`Document.xmlstring`\n        \"\"\"\n\n        self.pendingvalidation()\n\n        E = ElementMaker(namespace=\"http://ilk.uvt.nl/folia\",nsmap={'xml' : \"http://www.w3.org/XML/1998/namespace\", 'xlink':\"http://www.w3.org/1999/xlink\"})\n        attribs = {}\n        attribs['{http://www.w3.org/XML/1998/namespace}id'] = self.id\n\n        #if self.version:\n        #    attribs['version'] = self.version\n        #else:\n        attribs['version'] = FOLIAVERSION\n\n        attribs['generator'] = 'pynlpl.formats.folia-v' + LIBVERSION\n\n        metadataattribs = {}\n        metadataattribs['{' + NSFOLIA + '}type'] = self.metadatatype\n\n        if isinstance(self.metadata, ExternalMetaData):\n            metadataattribs['{' + NSFOLIA + '}src'] = self.metadata.url\n\n        e = E.FoLiA(\n            E.metadata(\n                E.annotations(\n                    *self.xmldeclarations()\n                ),\n                *self.xmlmetadata(),\n                **metadataattribs\n            )\n            , **attribs)\n        for text in self.data:\n            e.append(text.xml())\n        return e", "summary": "Serialise the document to XML.\n\n        Returns:\n            lxml.etree.Element\n\n        See also:\n            :meth:`Document.xmlstring`", "name": "xml", "complexity": 3, "num_dependencies": 10, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6733-L6773", "code_lines": 32, "summary_length": 137}
{"code": "def json(self):\n        \"\"\"Serialise the document to a ``dict`` ready for serialisation to JSON.\n\n        Example::\n\n            import json\n            jsondoc = json.dumps(doc.json())\n        \"\"\"\n        self.pendingvalidation()\n\n        jsondoc = {'id': self.id, 'children': [], 'declarations': self.jsondeclarations() }\n        if self.version:\n            jsondoc['version'] = self.version\n        else:\n            jsondoc['version'] = FOLIAVERSION\n        jsondoc['generator'] = 'pynlpl.formats.folia-v' + LIBVERSION\n\n        for text in self.data:\n            jsondoc['children'].append(text.json())\n        return jsondoc", "summary": "Serialise the document to a ``dict`` ready for serialisation to JSON.\n\n        Example::\n\n            import json\n            jsondoc = json.dumps(doc.json())", "name": "json", "complexity": 3, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6775-L6794", "code_lines": 16, "summary_length": 158}
{"code": "def xmlmetadata(self):\n        \"\"\"Internal method to serialize metadata to XML\"\"\"\n        E = ElementMaker(namespace=\"http://ilk.uvt.nl/folia\",nsmap={None: \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n        elements = []\n        if self.metadatatype == \"native\":\n            if isinstance(self.metadata, NativeMetaData):\n                for key, value in self.metadata.items():\n                    elements.append(E.meta(value,id=key) )\n        else:\n            if isinstance(self.metadata, ForeignData):\n                #in-document\n                m = self.metadata\n                while m is not None:\n                    elements.append(m.xml())\n                    m = m.next\n        for metadata_id, submetadata in self.submetadata.items():\n            subelements = []\n            attribs = {\n                \"{http://www.w3.org/XML/1998/namespace}id\": metadata_id,\n                \"type\": self.submetadatatype[metadata_id] }\n            if isinstance(submetadata, NativeMetaData):\n                for key, value in submetadata.items():\n                    subelements.append(E.meta(value,id=key) )\n            elif isinstance(submetadata, ExternalMetaData):\n                attribs['src'] = submetadata.url\n            elif isinstance(submetadata, ForeignData):\n                #in-document\n                m = submetadata\n                while m is not None:\n                    subelements.append(m.xml())\n                    m = m.next\n            elements.append( E.submetadata(*subelements, **attribs))\n        return elements", "summary": "Internal method to serialize metadata to XML", "name": "xmlmetadata", "complexity": 12, "num_dependencies": 19, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6796-L6828", "code_lines": 33, "summary_length": 44}
{"code": "def declare(self, annotationtype, set, **kwargs):\n        \"\"\"Declare a new annotation type to be used in the document.\n\n        Keyword arguments can be used to set defaults for any annotation of this type and set.\n\n        Arguments:\n            annotationtype: The type of annotation, this is conveyed by passing the corresponding annototion class (such as :class:`PosAnnotation` for example), or a member of :class:`AnnotationType`, such as ``AnnotationType.POS``.\n            set (str): the set, should formally be a URL pointing to the set definition\n\n        Keyword Arguments:\n            annotator (str): Sets a default annotator\n            annotatortype: Should be either ``AnnotatorType.MANUAL`` or ``AnnotatorType.AUTO``, indicating whether the annotation was performed manually or by an automated process.\n            datetime (datetime.datetime): Sets the default datetime\n            alias (str): Defines alias that may be used in set attribute of elements instead of the full set name\n\n        Example::\n\n            doc.declare(folia.PosAnnotation, 'http://some/path/brown-tag-set', annotator=\"mytagger\", annotatortype=folia.AnnotatorType.AUTO)\n        \"\"\"\n        if (sys.version > '3' and not isinstance(set,str)) or (sys.version < '3' and not isinstance(set,(str,unicode))):\n            raise ValueError(\"Set parameter for declare() must be a string\")\n\n        if inspect.isclass(annotationtype):\n            annotationtype = annotationtype.ANNOTATIONTYPE\n        if annotationtype in self.alias_set and set in self.alias_set[annotationtype]:\n            raise ValueError(\"Set \" + set + \" conflicts with alias, may not be equal!\")\n        if not (annotationtype, set) in self.annotations:\n            self.annotations.append( (annotationtype,set) )\n            if set and self.loadsetdefinitions and not set in self.setdefinitions:\n                if set[:7] == \"http://\" or set[:8] == \"https://\" or set[:6] == \"ftp://\":\n                    self.setdefinitions[set] = SetDefinition(set,verbose=self.verbose) #will raise exception on error\n        if not annotationtype in self.annotationdefaults:\n            self.annotationdefaults[annotationtype] = {}\n        self.annotationdefaults[annotationtype][set] = kwargs\n        if 'alias' in kwargs:\n            if annotationtype in self.set_alias and set in self.set_alias[annotationtype] and self.set_alias[annotationtype][set] != kwargs['alias']:\n                raise ValueError(\"Redeclaring set \" + set + \" with another alias ('\"+kwargs['alias']+\"') is not allowed!\")\n            if annotationtype in self.alias_set and kwargs['alias'] in self.alias_set[annotationtype] and self.alias_set[annotationtype][kwargs['alias']] != set:\n                raise ValueError(\"Redeclaring alias \" + kwargs['alias'] + \" with another set ('\"+set+\"') is not allowed!\")\n            if annotationtype in self.set_alias and kwargs['alias'] in self.set_alias[annotationtype]:\n                raise ValueError(\"Alias \" + kwargs['alias'] + \" conflicts with set name, may not be equal!\")\n            if annotationtype not in self.alias_set:\n                self.alias_set[annotationtype] = {}\n            if annotationtype not in self.set_alias:\n                self.set_alias[annotationtype] = {}\n            self.alias_set[annotationtype][kwargs['alias']] = set\n            self.set_alias[annotationtype][set] = kwargs['alias']", "summary": "Declare a new annotation type to be used in the document.\n\n        Keyword arguments can be used to set defaults for any annotation of this type and set.\n\n        Arguments:\n            annotationtype: The type of annotation, this is conveyed by passing the corresponding annototion class (such as :class:`PosAnnotation` for example), or a member of :class:`AnnotationType`, such as ``AnnotationType.POS``.\n            set (str): the set, should formally be a URL pointing to the set definition\n\n        Keyword Arguments:\n            annotator (str): Sets a default annotator\n            annotatortype: Should be either ``AnnotatorType.MANUAL`` or ``AnnotatorType.AUTO``, indicating whether the annotation was performed manually or by an automated process.\n            datetime (datetime.datetime): Sets the default datetime\n            alias (str): Defines alias that may be used in set attribute of elements instead of the full set name\n\n        Example::\n\n            doc.declare(folia.PosAnnotation, 'http://some/path/brown-tag-set', annotator=\"mytagger\", annotatortype=folia.AnnotatorType.AUTO)", "name": "declare", "complexity": 27, "num_dependencies": 10, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L6972-L7018", "code_lines": 41, "summary_length": 1100}
{"code": "def defaultset(self, annotationtype):\n        \"\"\"Obtain the default set for the specified annotation type.\n\n        Arguments:\n            annotationtype: The type of annotation, this is conveyed by passing the corresponding annototion class (such as :class:`PosAnnotation` for example), or a member of :class:`AnnotationType`, such as ``AnnotationType.POS``.\n\n        Returns:\n            the set (str)\n\n        Raises:\n            :class:`NoDefaultError` if the annotation type does not exist or if there is ambiguity (multiple sets for the same type)\n        \"\"\"\n\n        if inspect.isclass(annotationtype) or isinstance(annotationtype,AbstractElement): annotationtype = annotationtype.ANNOTATIONTYPE\n        try:\n            return list(self.annotationdefaults[annotationtype].keys())[0]\n        except KeyError:\n            raise NoDefaultError\n        except IndexError:\n            raise NoDefaultError", "summary": "Obtain the default set for the specified annotation type.\n\n        Arguments:\n            annotationtype: The type of annotation, this is conveyed by passing the corresponding annototion class (such as :class:`PosAnnotation` for example), or a member of :class:`AnnotationType`, such as ``AnnotationType.POS``.\n\n        Returns:\n            the set (str)\n\n        Raises:\n            :class:`NoDefaultError` if the annotation type does not exist or if there is ambiguity (multiple sets for the same type)", "name": "defaultset", "complexity": 5, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L7039-L7058", "code_lines": 16, "summary_length": 504}
{"code": "def defaultannotator(self, annotationtype, set=None):\n        \"\"\"Obtain the default annotator for the specified annotation type and set.\n\n        Arguments:\n            annotationtype: The type of annotation, this is conveyed by passing the corresponding annototion class (such as :class:`PosAnnotation` for example), or a member of :class:`AnnotationType`, such as ``AnnotationType.POS``.\n            set (str): the set, should formally be a URL pointing to the set definition\n\n        Returns:\n            the set (str)\n\n        Raises:\n            :class:`NoDefaultError` if the annotation type does not exist or if there is ambiguity (multiple sets for the same type)\n        \"\"\"\n\n        if inspect.isclass(annotationtype) or isinstance(annotationtype,AbstractElement): annotationtype = annotationtype.ANNOTATIONTYPE\n        if not set: set = self.defaultset(annotationtype)\n        try:\n            return self.annotationdefaults[annotationtype][set]['annotator']\n        except KeyError:\n            raise NoDefaultError", "summary": "Obtain the default annotator for the specified annotation type and set.\n\n        Arguments:\n            annotationtype: The type of annotation, this is conveyed by passing the corresponding annototion class (such as :class:`PosAnnotation` for example), or a member of :class:`AnnotationType`, such as ``AnnotationType.POS``.\n            set (str): the set, should formally be a URL pointing to the set definition\n\n        Returns:\n            the set (str)\n\n        Raises:\n            :class:`NoDefaultError` if the annotation type does not exist or if there is ambiguity (multiple sets for the same type)", "name": "defaultannotator", "complexity": 5, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L7061-L7080", "code_lines": 16, "summary_length": 606}
{"code": "def parsemetadata(self, node):\n        \"\"\"Internal method to parse metadata\"\"\"\n\n        if 'type' in node.attrib:\n            self.metadatatype = node.attrib['type']\n        else:\n            #no type specified, default to native\n            self.metadatatype = \"native\"\n\n        if 'src' in node.attrib:\n            self.metadata = ExternalMetaData(node.attrib['src'])\n        elif self.metadatatype == \"native\":\n            self.metadata = NativeMetaData()\n        else:\n            self.metadata = None #may be set below to ForeignData\n\n        for subnode in node:\n            if subnode.tag == '{' + NSFOLIA + '}annotations':\n                self.parsexmldeclarations(subnode)\n            elif subnode.tag == '{' + NSFOLIA + '}meta':\n                if self.metadatatype == \"native\":\n                    if subnode.text:\n                        self.metadata[subnode.attrib['id']] = subnode.text\n                else:\n                    raise MetaDataError(\"Encountered a meta element but metadata type is not native!\")\n            elif subnode.tag == '{' + NSFOLIA + '}provenance':\n                #forward compatibility with FoLiA 2.0; ignore provenance\n                print(\"WARNING: Ignoring provenance data. Use foliapy instead of pynlpl.formats.folia for FoLiA v2.0 compatibility!\",file=sys.stderr)\n                pass\n            elif subnode.tag == '{' + NSFOLIA + '}foreign-data':\n                if self.metadatatype == \"native\":\n                    raise MetaDataError(\"Encountered a foreign-data element but metadata type is native!\")\n                elif self.metadata is not None:\n                    #multiple foreign-data elements, chain:\n                    e = self.metadata\n                    while e.next is not None:\n                        e = e.next\n                    e.next = ForeignData(self, node=subnode)\n                else:\n                    self.metadata = ForeignData(self, node=subnode)\n            elif subnode.tag == '{' + NSFOLIA + '}submetadata':\n                self.parsesubmetadata(subnode)\n            elif subnode.tag == '{http://www.mpi.nl/IMDI/Schema/IMDI}METATRANSCRIPT': #backward-compatibility for old IMDI without foreign-key\n                E = ElementMaker(namespace=NSFOLIA,nsmap={None: NSFOLIA, 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n                self.metadatatype = \"imdi\"\n                self.metadata = ForeignData(self, node=subnode)", "summary": "Internal method to parse metadata", "name": "parsemetadata", "complexity": 16, "num_dependencies": 11, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L7216-L7261", "code_lines": 43, "summary_length": 33}
{"code": "def pendingvalidation(self, warnonly=None):\n        \"\"\"Perform any pending validations\n\n        Parameters:\n            warnonly (bool): Warn only (True) or raise exceptions (False). If set to None then this value will be determined based on the document's FoLiA version (Warn only before FoLiA v1.5)\n\n        Returns:\n            bool\n        \"\"\"\n        if self.debug: print(\"[PyNLPl FoLiA DEBUG] Processing pending validations (if any)\",file=stderr)\n\n        if warnonly is None and self and self.version:\n            warnonly = (checkversion(self.version, '1.5.0') < 0) #warn only for documents older than FoLiA v1.5\n        if self.textvalidation:\n            while self.offsetvalidationbuffer:\n                structureelement, textclass = self.offsetvalidationbuffer.pop()\n\n                if self.debug: print(\"[PyNLPl FoLiA DEBUG] Performing offset validation on \" + repr(structureelement) + \" textclass \" + textclass,file=stderr)\n\n                #validate offsets\n                tc = structureelement.textcontent(textclass)\n                if tc.offset is not None:\n                    try:\n                        tc.getreference(validate=True)\n                    except UnresolvableTextContent:\n                        msg = \"Text for \" + structureelement.__class__.__name__ + \", ID \" + str(structureelement.id) + \", textclass \" + textclass  + \", has incorrect offset \" + str(tc.offset) + \" or invalid reference\"\n                        print(\"TEXT VALIDATION ERROR: \" + msg,file=sys.stderr)\n                        if not warnonly:\n                            raise", "summary": "Perform any pending validations\n\n        Parameters:\n            warnonly (bool): Warn only (True) or raise exceptions (False). If set to None then this value will be determined based on the document's FoLiA version (Warn only before FoLiA v1.5)\n\n        Returns:\n            bool", "name": "pendingvalidation", "complexity": 11, "num_dependencies": 10, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L7396-L7424", "code_lines": 24, "summary_length": 280}
{"code": "def paragraphs(self, index = None):\n        \"\"\"Return a generator of all paragraphs found in the document.\n\n        If an index is specified, return the n'th paragraph only (starting at 0)\"\"\"\n        if index is None:\n            return self.select(Paragraph)\n        else:\n            if index < 0:\n                index = sum(t.count(Paragraph) for t in self.data) + index\n            for t in self.data:\n                for i,e in enumerate(t.select(Paragraph)) :\n                    if i == index:\n                        return e\n            raise IndexError", "summary": "Return a generator of all paragraphs found in the document.\n\n        If an index is specified, return the n'th paragraph only (starting at 0)", "name": "paragraphs", "complexity": 6, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L7445-L7458", "code_lines": 13, "summary_length": 141}
{"code": "def sentences(self, index = None):\n        \"\"\"Return a generator of all sentence found in the document. Except for sentences in quotes.\n\n        If an index is specified, return the n'th sentence only (starting at 0)\"\"\"\n        if index is None:\n            return self.select(Sentence,None,True,[Quote])\n        else:\n            if index < 0:\n                index = sum(t.count(Sentence,None,True,[Quote]) for t in self.data) + index\n            for t in self.data:\n                for i,e in enumerate(t.select(Sentence,None,True,[Quote])) :\n                    if i == index:\n                        return e\n            raise IndexError", "summary": "Return a generator of all sentence found in the document. Except for sentences in quotes.\n\n        If an index is specified, return the n'th sentence only (starting at 0)", "name": "sentences", "complexity": 6, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/folia.py#L7460-L7473", "code_lines": 13, "summary_length": 170}
{"code": "def _states(self, state, processedstates=[]): #pylint: disable=dangerous-default-value\n        \"\"\"Iterate over all states in no particular order\"\"\"\n        processedstates.append(state)\n\n        for nextstate in state.epsilon:\n            if not nextstate in processedstates:\n                self._states(nextstate, processedstates)\n\n        for _, nextstate in state.transitions:\n            if not nextstate in processedstates:\n                self._states(nextstate, processedstates)\n\n        return processedstates", "summary": "Iterate over all states in no particular order", "name": "_states", "complexity": 5, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/fsa.py#L97-L109", "code_lines": 10, "summary_length": 46}
{"code": "def log(msg, **kwargs):\n    \"\"\"Generic log method. Will prepend timestamp.\n\n    Keyword arguments:\n      system   - Name of the system/module\n      indent   - Integer denoting the desired level of indentation\n      streams  - List of streams to output to\n      stream   - Stream to output to (singleton version of streams)\n    \"\"\"\n    if 'debug' in kwargs:\n        if 'currentdebug' in kwargs:\n            if kwargs['currentdebug'] < kwargs['debug']:\n                return False\n        else:\n            return False #no currentdebug passed, assuming no debug mode and thus skipping message\n\n    s = \"[\" + datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") + \"] \"\n    if 'system' in kwargs:\n        s += \"[\" + system + \"] \"\n\n\n    if 'indent' in kwargs:\n        s += (\"\\t\" * int(kwargs['indent']))\n\n    s += u(msg)\n\n    if s[-1] != '\\n':\n        s += '\\n'\n\n    if 'streams' in kwargs:\n        streams = kwargs['streams']\n    elif 'stream' in kwargs:\n        streams = [kwargs['stream']]\n    else:\n        streams = [stderr]\n\n    for stream in streams:\n        stream.write(s)\n    return s", "summary": "Generic log method. Will prepend timestamp.\n\n    Keyword arguments:\n      system   - Name of the system/module\n      indent   - Integer denoting the desired level of indentation\n      streams  - List of streams to output to\n      stream   - Stream to output to (singleton version of streams)", "name": "log", "complexity": 10, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/common.py#L98-L136", "code_lines": 31, "summary_length": 291}
{"code": "def get_syn_ids_by_lemma(self, lemma):\n        \"\"\"Returns a list of synset IDs based on a lemma\"\"\"\n        if not isinstance(lemma,unicode):\n            lemma = unicode(lemma,'utf-8')\n\n\n        http, resp, content = self.connect()\n\n        params   = \"\"\n        fragment = \"\"\n\n        path = \"cdb_syn\"\n        if self.debug:\n            printf( \"cornettodb/views/query_remote_syn_lemma: db_opt: %s\" % path )\n\n        query_opt = \"dict_search\"\n        if self.debug:\n            printf( \"cornettodb/views/query_remote_syn_lemma: query_opt: %s\" % query_opt )\n    \n        qdict = {}\n        qdict[ \"action\" ] = \"queryList\"\n        qdict[ \"word\" ]   = lemma.encode('utf-8')\n\n\n        query = urllib.urlencode( qdict )\n\n        db_url_tuple = ( self.scheme, self.host + ':' + str(self.port), path, params, query, fragment )\n        db_url = urlparse.urlunparse( db_url_tuple )\n        if self.debug:\n            printf( \"db_url: %s\" % db_url )\n\n        resp, content = http.request( db_url, \"GET\" )\n        if self.debug:\n            printf( \"resp:\\n%s\" % resp )\n            printf( \"content:\\n%s\" % content )\n        #    printf( \"content is of type: %s\" % type( content ) )\n\n        dict_list = []\n        dict_list = eval( content )        # string to list\n\n        synsets = []\n        items = len( dict_list )\n        if self.debug:\n            printf( \"items: %d\" % items )\n\n        # syn dict: like lu dict, but without pos: part-of-speech\n        for dict in dict_list:\n            if self.debug:\n                printf( dict )\n\n            seq_nr = dict[ \"seq_nr\" ]   # sense number\n            value  = dict[ \"value\" ]    # lexical unit identifier\n            form   = dict[ \"form\" ]     # lemma\n            label  = dict[ \"label\" ]    # label to be shown\n\n            if self.debug:\n                printf( \"seq_nr: %s\" % seq_nr )\n                printf( \"value:  %s\" % value )\n                printf( \"form:   %s\" % form )\n                printf( \"label:  %s\" % label )\n\n            if value != \"\":\n                synsets.append( value )\n\n        return synsets", "summary": "Returns a list of synset IDs based on a lemma", "name": "get_syn_ids_by_lemma", "complexity": 11, "num_dependencies": 22, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/clients/cornetto.py#L96-L160", "code_lines": 48, "summary_length": 45}
{"code": "def get_synset_xml(self,syn_id):\n        \"\"\"\n        call cdb_syn with synset identifier -> returns the synset xml;\n        \"\"\"\n\n        http, resp, content = self.connect()\n\n        params   = \"\"\n        fragment = \"\"\n\n        path = \"cdb_syn\"\n        if self.debug:\n            printf( \"cornettodb/views/query_remote_syn_id: db_opt: %s\" % path )\n\n        # output_opt: plain, html, xml\n        # 'xml' is actually xhtml (with markup), but it is not valid xml!\n        # 'plain' is actually valid xml (without markup)\n        output_opt = \"plain\"\n        if self.debug:\n            printf( \"cornettodb/views/query_remote_syn_id: output_opt: %s\" % output_opt )\n\n        action = \"runQuery\"\n        if self.debug:\n            printf( \"cornettodb/views/query_remote_syn_id: action: %s\" % action )\n            printf( \"cornettodb/views/query_remote_syn_id: query: %s\" % syn_id )\n\n        qdict = {}\n        qdict[ \"action\" ]  = action\n        qdict[ \"query\" ]   = syn_id\n        qdict[ \"outtype\" ] = output_opt\n\n        query = urllib.urlencode( qdict )\n\n        db_url_tuple = ( self.scheme, self.host + ':' + str(self.port), path, params, query, fragment )\n        db_url = urlparse.urlunparse( db_url_tuple )\n        if self.debug:\n            printf( \"db_url: %s\" % db_url )\n\n        resp, content = http.request( db_url, \"GET\" )\n        if self.debug:\n            printf( \"resp:\\n%s\" % resp )\n        #    printf( \"content:\\n%s\" % content )\n        #    printf( \"content is of type: %s\" % type( content ) )        #<type 'str'>\n\n        xml_data = eval( content )\n        return etree.fromstring( xml_data )", "summary": "call cdb_syn with synset identifier -> returns the synset xml;", "name": "get_synset_xml", "complexity": 6, "num_dependencies": 13, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/clients/cornetto.py#L227-L272", "code_lines": 36, "summary_length": 62}
{"code": "def senses(self, bestonly=False):\n        \"\"\"Returns a list of all predicted senses\"\"\"\n        l = []\n        for word_id, senses,distance in self:\n            for sense, confidence in senses:\n                if not sense in l: l.append(sense)\n                if bestonly:\n                    break\n        return l", "summary": "Returns a list of all predicted senses", "name": "senses", "complexity": 5, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/dutchsemcor.py#L139-L147", "code_lines": 9, "summary_length": 38}
{"code": "def align(self,inputwords, outputwords):\n        \"\"\"For each inputword, provides the index of the outputword\"\"\"\n        alignment = []\n        cursor = 0\n        for inputword in inputwords:\n            if len(outputwords) > cursor and outputwords[cursor] == inputword:\n                alignment.append(cursor)\n                cursor += 1\n            elif len(outputwords) > cursor+1 and outputwords[cursor+1] == inputword:\n                alignment.append(cursor+1)\n                cursor += 2\n            else:\n                alignment.append(None)\n                cursor += 1\n        return alignment", "summary": "For each inputword, provides the index of the outputword", "name": "align", "complexity": 6, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/clients/frogclient.py#L115-L129", "code_lines": 15, "summary_length": 56}
{"code": "def tokenize(text, regexps=TOKENIZERRULES):\n    \"\"\"Tokenizes a string and returns a list of tokens\n\n    :param text: The text to tokenise\n    :type text: string\n    :param regexps: Regular expressions to use as tokeniser rules in tokenisation (default=_pynlpl.textprocessors.TOKENIZERRULES_)\n    :type regexps:  Tuple/list of regular expressions to use in tokenisation\n    :rtype: Returns a list of tokens\n\n    Examples:\n\n    >>> for token in tokenize(\"This is a test.\"):\n    ...    print(token)\n    This\n    is\n    a\n    test\n    .\n\n\n    \"\"\"\n\n    for i,regexp in list(enumerate(regexps)):\n        if isstring(regexp):\n            regexps[i] = re.compile(regexp)\n\n    tokens = []\n    begin = 0\n    for i, c in enumerate(text):\n        if begin > i:\n            continue\n        elif i == begin:\n            m = False\n            for regexp in regexps:\n                m = regexp.findall(text[i:i+300])\n                if m:\n                    tokens.append(m[0])\n                    begin = i + len(m[0])\n                    break\n            if m: continue\n\n        if c in string.punctuation or c in WHITESPACE:\n            prev = text[i-1] if i > 0 else \"\"\n            next = text[i+1] if i < len(text)-1 else \"\"\n\n            if (c == '.' or c == ',') and prev.isdigit() and next.isdigit():\n                #punctuation in between numbers, keep as one token\n                pass\n            elif (c == \"'\" or c == \"`\") and prev.isalpha() and next.isalpha():\n                #quote in between chars, keep...\n                pass\n            elif c not in WHITESPACE and next == c: #group clusters of identical punctuation together\n                continue\n            elif c == '\\r' and prev == '\\n':\n                #ignore\n                begin = i+1\n                continue\n            else:\n                token = text[begin:i]\n                if token: tokens.append(token)\n\n                if c not in WHITESPACE:\n                    tokens.append(c) #anything but spaces and newlines (i.e. punctuation) counts as a token too\n                begin = i + 1 #set the begin cursor\n\n    if begin <= len(text) - 1:\n        token = text[begin:]\n        tokens.append(token)\n\n    return tokens", "summary": "Tokenizes a string and returns a list of tokens\n\n    :param text: The text to tokenise\n    :type text: string\n    :param regexps: Regular expressions to use as tokeniser rules in tokenisation (default=_pynlpl.textprocessors.TOKENIZERRULES_)\n    :type regexps:  Tuple/list of regular expressions to use in tokenisation\n    :rtype: Returns a list of tokens\n\n    Examples:\n\n    >>> for token in tokenize(\"This is a test.\"):\n    ...    print(token)\n    This\n    is\n    a\n    test\n    .", "name": "tokenize", "complexity": 26, "num_dependencies": 17, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/textprocessors.py#L317-L386", "code_lines": 58, "summary_length": 481}
{"code": "def strip_accents(s, encoding= 'utf-8'):\n    \"\"\"Strip characters with diacritics and return a flat ascii representation\"\"\"\n    if sys.version < '3':\n        if isinstance(s,unicode):\n           return unicodedata.normalize('NFKD', s).encode('ASCII', 'ignore')\n        else:\n           return unicodedata.normalize('NFKD', unicode(s,encoding)).encode('ASCII', 'ignore')\n    else:\n        if isinstance(s,bytes): s = str(s,encoding)\n        return str(unicodedata.normalize('NFKD', s).encode('ASCII', 'ignore'),'ascii')", "summary": "Strip characters with diacritics and return a flat ascii representation", "name": "strip_accents", "complexity": 4, "num_dependencies": 7, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/textprocessors.py#L415-L424", "code_lines": 10, "summary_length": 71}
{"code": "def swap(tokens, maxdist=2):\n    \"\"\"Perform a swap operation on a sequence of tokens, exhaustively swapping all tokens up to the maximum specified distance. This is a subset of all permutations.\"\"\"\n    assert maxdist >= 2\n    tokens = list(tokens)\n    if maxdist > len(tokens):\n        maxdist = len(tokens)\n    l = len(tokens)\n    for i in range(0,l - 1):\n        for permutation in permutations(tokens[i:i+maxdist]):\n            if permutation != tuple(tokens[i:i+maxdist]):\n                newtokens = tokens[:i]\n                newtokens += permutation\n                newtokens += tokens[i+maxdist:]\n                yield newtokens\n        if maxdist == len(tokens):\n            break", "summary": "Perform a swap operation on a sequence of tokens, exhaustively swapping all tokens up to the maximum specified distance. This is a subset of all permutations.", "name": "swap", "complexity": 6, "num_dependencies": 8, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/textprocessors.py#L426-L441", "code_lines": 16, "summary_length": 158}
{"code": "def find_keyword_in_context(tokens, keyword, contextsize=1):\n    \"\"\"Find a keyword in a particular sequence of tokens, and return the local context. Contextsize is the number of words to the left and right. The keyword may have multiple word, in which case it should to passed as a tuple or list\"\"\"\n    if isinstance(keyword,tuple) and isinstance(keyword,list):\n        l = len(keyword)\n    else:\n        keyword = (keyword,)\n        l = 1\n    n = l + contextsize*2\n    focuspos = contextsize + 1\n    for ngram in Windower(tokens,n,None,None):\n        if ngram[focuspos:focuspos+l] == keyword:\n            yield ngram[:focuspos], ngram[focuspos:focuspos+l],ngram[focuspos+l+1:]", "summary": "Find a keyword in a particular sequence of tokens, and return the local context. Contextsize is the number of words to the left and right. The keyword may have multiple word, in which case it should to passed as a tuple or list", "name": "find_keyword_in_context", "complexity": 5, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/textprocessors.py#L444-L455", "code_lines": 12, "summary_length": 227}
{"code": "def randomprune(self,n):\n        \"\"\"prune down to n items at random, disregarding their score\"\"\"\n        self.data = random.sample(self.data, n)", "summary": "prune down to n items at random, disregarding their score", "name": "randomprune", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/datatypes.py#L196-L198", "code_lines": 3, "summary_length": 57}
{"code": "def append(self, item):\n        \"\"\"Add an item to the Tree\"\"\"\n        if not isinstance(item, Tree):\n            return ValueError(\"Can only append items of type Tree\")\n        if not self.children: self.children = []\n        item.parent = self\n        self.children.append(item)", "summary": "Add an item to the Tree", "name": "append", "complexity": 3, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/datatypes.py#L261-L267", "code_lines": 7, "summary_length": 23}
{"code": "def size(self):\n        \"\"\"Size is number of nodes under the trie, including the current node\"\"\"\n        if self.children:\n            return sum( ( c.size() for c in self.children.values() ) ) + 1\n        else:\n            return 1", "summary": "Size is number of nodes under the trie, including the current node", "name": "size", "complexity": 2, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/datatypes.py#L361-L366", "code_lines": 6, "summary_length": 66}
{"code": "def validate(self, formats_dir=\"../formats/\"):\n        \"\"\"checks if the document is valid\"\"\"\n        #TODO: download XSD from web\n        if self.inline:\n            xmlschema = ElementTree.XMLSchema(ElementTree.parse(StringIO(\"\\n\".join(open(formats_dir+\"dcoi-dsc.xsd\").readlines()))))\n            xmlschema.assertValid(self.tree)\n            #return xmlschema.validate(self)\n        else:\n            xmlschema = ElementTree.XMLSchema(ElementTree.parse(StringIO(\"\\n\".join(open(formats_dir+\"dutchsemcor-standalone.xsd\").readlines()))))\n            xmlschema.assertValid(self.tree)", "summary": "checks if the document is valid", "name": "validate", "complexity": 2, "num_dependencies": 12, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/sonar.py#L235-L244", "code_lines": 10, "summary_length": 31}
{"code": "def xpath(self, expression):\n        \"\"\"Executes an xpath expression using the correct namespaces\"\"\"\n        global namespaces\n        return self.tree.xpath(expression, namespaces=namespaces)", "summary": "Executes an xpath expression using the correct namespaces", "name": "xpath", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/sonar.py#L247-L250", "code_lines": 4, "summary_length": 57}
{"code": "def align(self, referencewords, datatuple):\n        \"\"\"align the reference sentence with the tagged data\"\"\"\n        targetwords = []\n        for i, (word,lemma,postag) in enumerate(zip(datatuple[0],datatuple[1],datatuple[2])):\n            if word:\n                subwords = word.split(\"_\")\n                for w in subwords: #split multiword expressions\n                    targetwords.append( (w, lemma, postag, i, len(subwords) > 1 ) ) #word, lemma, pos, index, multiword? \n\n        referencewords = [ w.lower() for w in referencewords ]          \n        alignment = []\n        for i, referenceword in enumerate(referencewords):\n            found = False\n            best = 0  \n            distance = 999999          \n            for j, (targetword, lemma, pos, index, multiword) in enumerate(targetwords):\n                if referenceword == targetword and abs(i-j) < distance:\n                    found = True\n                    best = j\n                    distance = abs(i-j)\n\n            if found:\n                alignment.append(targetwords[best])\n            else:                \n                alignment.append((None,None,None,None,False)) #no alignment found        \n        \n        return alignment", "summary": "align the reference sentence with the tagged data", "name": "align", "complexity": 9, "num_dependencies": 12, "language": "python", "source_url": "https://github.com/proycon/pynlpl/blob/7707f69a91caaa6cde037f0d0379f1d42500a68b/pynlpl/formats/taggerdata.py#L99-L125", "code_lines": 24, "summary_length": 49}
{"code": "def build(self, **kwargs):\n        \"\"\"Build the lexer.\"\"\"\n        self.lexer = ply.lex.lex(object=self, **kwargs)", "summary": "Build the lexer.", "name": "build", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/scrapinghub/js2xml/blob/d01b79e1a82de157deffcc1a22f4e0b6bfa07715/js2xml/lexer.py#L74-L76", "code_lines": 3, "summary_length": 16}
{"code": "def is_authorized(self, request):\n        \"\"\"Check if the user is authenticated for the given request.\n\n        The include_paths and exclude_paths are first checked. If\n        authentication is required then the Authorization HTTP header is\n        checked against the credentials.\n\n        \"\"\"\n        if self._is_request_in_include_path(request):\n            if self._is_request_in_exclude_path(request):\n                return True\n            else:\n                auth = request.authorization\n                if auth and auth[0] == 'Basic':\n                    credentials = b64decode(auth[1]).decode('UTF-8')\n                    username, password = credentials.split(':', 1)\n                    return self._users.get(username) == password\n                else:\n                    return False\n        else:\n            return True", "summary": "Check if the user is authenticated for the given request.\n\n        The include_paths and exclude_paths are first checked. If\n        authentication is required then the Authorization HTTP header is\n        checked against the credentials.", "name": "is_authorized", "complexity": 5, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/mvantellingen/wsgi-basic-auth/blob/4e829bff21526f587f8d1a8592b63e1abd862a74/src/wsgi_basic_auth.py#L48-L68", "code_lines": 19, "summary_length": 238}
{"code": "def _login(self, environ, start_response):\n        \"\"\"Send a login response back to the client.\"\"\"\n        response = HTTPUnauthorized()\n        response.www_authenticate = ('Basic', {'realm': self._realm})\n        return response(environ, start_response)", "summary": "Send a login response back to the client.", "name": "_login", "complexity": 1, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/mvantellingen/wsgi-basic-auth/blob/4e829bff21526f587f8d1a8592b63e1abd862a74/src/wsgi_basic_auth.py#L70-L74", "code_lines": 5, "summary_length": 41}
{"code": "def _is_request_in_include_path(self, request):\n        \"\"\"Check if the request path is in the `_include_paths` list.\n\n        If no specific include paths are given then we assume that\n        authentication is required for all paths.\n\n        \"\"\"\n        if self._include_paths:\n            for path in self._include_paths:\n                if request.path.startswith(path):\n                    return True\n            return False\n        else:\n            return True", "summary": "Check if the request path is in the `_include_paths` list.\n\n        If no specific include paths are given then we assume that\n        authentication is required for all paths.", "name": "_is_request_in_include_path", "complexity": 4, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/mvantellingen/wsgi-basic-auth/blob/4e829bff21526f587f8d1a8592b63e1abd862a74/src/wsgi_basic_auth.py#L76-L89", "code_lines": 12, "summary_length": 176}
{"code": "def _is_request_in_exclude_path(self, request):\n        \"\"\"Check if the request path is in the `_exclude_paths` list\"\"\"\n        if self._exclude_paths:\n            for path in self._exclude_paths:\n                if request.path.startswith(path):\n                    return True\n            return False\n        else:\n            return False", "summary": "Check if the request path is in the `_exclude_paths` list", "name": "_is_request_in_exclude_path", "complexity": 4, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/mvantellingen/wsgi-basic-auth/blob/4e829bff21526f587f8d1a8592b63e1abd862a74/src/wsgi_basic_auth.py#L91-L99", "code_lines": 9, "summary_length": 57}
{"code": "def bootstrap_prompt(prompt_kwargs, group):\n    \"\"\"\n    Bootstrap prompt_toolkit kwargs or use user defined values.\n\n    :param prompt_kwargs: The user specified prompt kwargs.\n    \"\"\"\n    prompt_kwargs = prompt_kwargs or {}\n\n    defaults = {\n        \"history\": InMemoryHistory(),\n        \"completer\": ClickCompleter(group),\n        \"message\": u\"> \",\n    }\n\n    for key in defaults:\n        default_value = defaults[key]\n        if key not in prompt_kwargs:\n            prompt_kwargs[key] = default_value\n\n    return prompt_kwargs", "summary": "Bootstrap prompt_toolkit kwargs or use user defined values.\n\n    :param prompt_kwargs: The user specified prompt kwargs.", "name": "bootstrap_prompt", "complexity": 4, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/click-contrib/click-repl/blob/2d78dc520eb0bb5b813bad3b72344edbd22a7f4e/click_repl/__init__.py#L146-L165", "code_lines": 16, "summary_length": 120}
{"code": "def repl(  # noqa: C901\n    old_ctx,\n    prompt_kwargs=None,\n    allow_system_commands=True,\n    allow_internal_commands=True,\n):\n    \"\"\"\n    Start an interactive shell. All subcommands are available in it.\n\n    :param old_ctx: The current Click context.\n    :param prompt_kwargs: Parameters passed to\n        :py:func:`prompt_toolkit.shortcuts.prompt`.\n\n    If stdin is not a TTY, no prompt will be printed, but only commands read\n    from stdin.\n\n    \"\"\"\n    # parent should be available, but we're not going to bother if not\n    group_ctx = old_ctx.parent or old_ctx\n    group = group_ctx.command\n    isatty = sys.stdin.isatty()\n\n    # Delete the REPL command from those available, as we don't want to allow\n    # nesting REPLs (note: pass `None` to `pop` as we don't want to error if\n    # REPL command already not present for some reason).\n    repl_command_name = old_ctx.command.name\n    if isinstance(group_ctx.command, click.CommandCollection):\n        available_commands = {\n            cmd_name: cmd_obj\n            for source in group_ctx.command.sources\n            for cmd_name, cmd_obj in source.commands.items()\n        }\n    else:\n        available_commands = group_ctx.command.commands\n    available_commands.pop(repl_command_name, None)\n\n    prompt_kwargs = bootstrap_prompt(prompt_kwargs, group)\n\n    if isatty:\n\n        def get_command():\n            return prompt(**prompt_kwargs)\n\n    else:\n        get_command = sys.stdin.readline\n\n    while True:\n        try:\n            command = get_command()\n        except KeyboardInterrupt:\n            continue\n        except EOFError:\n            break\n\n        if not command:\n            if isatty:\n                continue\n            else:\n                break\n\n        if allow_system_commands and dispatch_repl_commands(command):\n            continue\n\n        if allow_internal_commands:\n            try:\n                result = handle_internal_commands(command)\n                if isinstance(result, six.string_types):\n                    click.echo(result)\n                    continue\n            except ExitReplException:\n                break\n\n        try:\n            args = shlex.split(command)\n        except ValueError as e:\n            click.echo(\"{}: {}\".format(type(e).__name__, e))\n            continue\n\n        try:\n            with group.make_context(None, args, parent=group_ctx) as ctx:\n                group.invoke(ctx)\n                ctx.exit()\n        except click.ClickException as e:\n            e.show()\n        except ClickExit:\n            pass\n        except SystemExit:\n            pass\n        except ExitReplException:\n            break", "summary": "Start an interactive shell. All subcommands are available in it.\n\n    :param old_ctx: The current Click context.\n    :param prompt_kwargs: Parameters passed to\n        :py:func:`prompt_toolkit.shortcuts.prompt`.\n\n    If stdin is not a TTY, no prompt will be printed, but only commands read\n    from stdin.", "name": "repl", "complexity": 19, "num_dependencies": 19, "language": "python", "source_url": "https://github.com/click-contrib/click-repl/blob/2d78dc520eb0bb5b813bad3b72344edbd22a7f4e/click_repl/__init__.py#L168-L257", "code_lines": 76, "summary_length": 305}
{"code": "def handle_internal_commands(command):\n    \"\"\"Run repl-internal commands.\n\n    Repl-internal commands are all commands starting with \":\".\n\n    \"\"\"\n    if command.startswith(\":\"):\n        target = _get_registered_target(command[1:], default=None)\n        if target:\n            return target()", "summary": "Run repl-internal commands.\n\n    Repl-internal commands are all commands starting with \":\".", "name": "handle_internal_commands", "complexity": 3, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/click-contrib/click-repl/blob/2d78dc520eb0bb5b813bad3b72344edbd22a7f4e/click_repl/__init__.py#L283-L292", "code_lines": 8, "summary_length": 91}
{"code": "def node_definitions(id_fetcher, type_resolver=None, id_resolver=None):\n    '''\n    Given a function to map from an ID to an underlying object, and a function\n    to map from an underlying object to the concrete GraphQLObjectType it\n    corresponds to, constructs a `Node` interface that objects can implement,\n    and a field config for a `node` root field.\n\n    If the type_resolver is omitted, object resolution on the interface will be\n    handled with the `isTypeOf` method on object types, as with any GraphQL\n    interface without a provided `resolveType` method.\n    '''\n    node_interface = GraphQLInterfaceType(\n        'Node',\n        description='An object with an ID',\n        fields=lambda: OrderedDict((\n            ('id', GraphQLField(\n                GraphQLNonNull(GraphQLID),\n                description='The id of the object.',\n                resolver=id_resolver,\n            )),\n        )),\n        resolve_type=type_resolver\n    )\n    node_field = GraphQLField(\n        node_interface,\n        description='Fetches an object given its ID',\n        args=OrderedDict((\n            ('id', GraphQLArgument(\n                GraphQLNonNull(GraphQLID),\n                description='The ID of an object'\n            )),\n        )),\n        resolver=lambda obj, args, *_: id_fetcher(args.get('id'), *_)\n    )\n    return node_interface, node_field", "summary": "Given a function to map from an ID to an underlying object, and a function\n    to map from an underlying object to the concrete GraphQLObjectType it\n    corresponds to, constructs a `Node` interface that objects can implement,\n    and a field config for a `node` root field.\n\n    If the type_resolver is omitted, object resolution on the interface will be\n    handled with the `isTypeOf` method on object types, as with any GraphQL\n    interface without a provided `resolveType` method.", "name": "node_definitions", "complexity": 1, "num_dependencies": 10, "language": "python", "source_url": "https://github.com/graphql-python/graphql-relay-py/blob/17ce2efa3c396df42791ae00667120b5fae64610/graphql_relay/node/node.py#L15-L49", "code_lines": 34, "summary_length": 486}
{"code": "def from_global_id(global_id):\n    '''\n    Takes the \"global ID\" created by toGlobalID, and retuns the type name and ID\n    used to create it.\n    '''\n    unbased_global_id = unbase64(global_id)\n    _type, _id = unbased_global_id.split(':', 1)\n    return _type, _id", "summary": "Takes the \"global ID\" created by toGlobalID, and retuns the type name and ID\n    used to create it.", "name": "from_global_id", "complexity": 1, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/graphql-python/graphql-relay-py/blob/17ce2efa3c396df42791ae00667120b5fae64610/graphql_relay/node/node.py#L60-L67", "code_lines": 8, "summary_length": 99}
{"code": "def global_id_field(type_name, id_fetcher=None):\n    '''\n    Creates the configuration for an id field on a node, using `to_global_id` to\n    construct the ID from the provided typename. The type-specific ID is fetcher\n    by calling id_fetcher on the object, or if not provided, by accessing the `id`\n    property on the object.\n    '''\n    return GraphQLField(\n        GraphQLNonNull(GraphQLID),\n        description='The ID of an object',\n        resolver=lambda obj, args, context, info: to_global_id(\n            type_name or info.parent_type.name,\n            id_fetcher(obj, context, info) if id_fetcher else obj.id\n        )\n    )", "summary": "Creates the configuration for an id field on a node, using `to_global_id` to\n    construct the ID from the provided typename. The type-specific ID is fetcher\n    by calling id_fetcher on the object, or if not provided, by accessing the `id`\n    property on the object.", "name": "global_id_field", "complexity": 2, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/graphql-python/graphql-relay-py/blob/17ce2efa3c396df42791ae00667120b5fae64610/graphql_relay/node/node.py#L70-L84", "code_lines": 15, "summary_length": 268}
{"code": "def connection_from_list(data, args=None, **kwargs):\n    '''\n    A simple function that accepts an array and connection arguments, and returns\n    a connection object for use in GraphQL. It uses array offsets as pagination,\n    so pagination will only work if the array is static.\n    '''\n    _len = len(data)\n    return connection_from_list_slice(\n        data,\n        args,\n        slice_start=0,\n        list_length=_len,\n        list_slice_length=_len,\n        **kwargs\n    )", "summary": "A simple function that accepts an array and connection arguments, and returns\n    a connection object for use in GraphQL. It uses array offsets as pagination,\n    so pagination will only work if the array is static.", "name": "connection_from_list", "complexity": 1, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/graphql-python/graphql-relay-py/blob/17ce2efa3c396df42791ae00667120b5fae64610/graphql_relay/connection/arrayconnection.py#L7-L21", "code_lines": 15, "summary_length": 215}
{"code": "def connection_from_promised_list(data_promise, args=None, **kwargs):\n    '''\n    A version of `connectionFromArray` that takes a promised array, and returns a\n    promised connection.\n    '''\n    return data_promise.then(lambda data: connection_from_list(data, args, **kwargs))", "summary": "A version of `connectionFromArray` that takes a promised array, and returns a\n    promised connection.", "name": "connection_from_promised_list", "complexity": 1, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/graphql-python/graphql-relay-py/blob/17ce2efa3c396df42791ae00667120b5fae64610/graphql_relay/connection/arrayconnection.py#L24-L29", "code_lines": 6, "summary_length": 102}
{"code": "def cursor_for_object_in_connection(data, _object):\n    '''\n    Return the cursor associated with an object in an array.\n    '''\n    if _object not in data:\n        return None\n\n    offset = data.index(_object)\n    return offset_to_cursor(offset)", "summary": "Return the cursor associated with an object in an array.", "name": "cursor_for_object_in_connection", "complexity": 2, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/graphql-python/graphql-relay-py/blob/17ce2efa3c396df42791ae00667120b5fae64610/graphql_relay/connection/arrayconnection.py#L134-L142", "code_lines": 8, "summary_length": 56}
{"code": "def get_offset_with_default(cursor=None, default_offset=0):\n    '''\n    Given an optional cursor and a default offset, returns the offset\n    to use; if the cursor contains a valid offset, that will be used,\n    otherwise it will be the default.\n    '''\n    if not is_str(cursor):\n        return default_offset\n\n    offset = cursor_to_offset(cursor)\n    try:\n        return int(offset)\n    except:\n        return default_offset", "summary": "Given an optional cursor and a default offset, returns the offset\n    to use; if the cursor contains a valid offset, that will be used,\n    otherwise it will be the default.", "name": "get_offset_with_default", "complexity": 3, "num_dependencies": 3, "language": "python", "source_url": "https://github.com/graphql-python/graphql-relay-py/blob/17ce2efa3c396df42791ae00667120b5fae64610/graphql_relay/connection/arrayconnection.py#L145-L158", "code_lines": 13, "summary_length": 173}
{"code": "def generate(data, iterations=1000, force_strength=5.0, dampening=0.01,\n             max_velocity=2.0, max_distance=50, is_3d=True):\n    \"\"\"Runs a force-directed algorithm on a graph, returning a data structure.\n\n    Args:\n        data: An adjacency list of tuples (ie. [(1,2),...])\n        iterations: (Optional) Number of FDL iterations to run in coordinate\n            generation\n        force_strength: (Optional) Strength of Coulomb and Hooke forces\n            (edit this to scale the distance between nodes)\n        dampening: (Optional) Multiplier to reduce force applied to nodes\n        max_velocity: (Optional) Maximum distance a node can move in one step\n        max_distance: (Optional) The maximum inter-node distance considered\n        is_3d: (Optional) Generates three-dimensional coordinates\n\n    Outputs a json-serializable Python object. To visualize, pass the output to\n    `jgraph.draw(...)`.\n    \"\"\"\n\n    edges = [{'source': s, 'target': t} for s, t in data]\n    nodes = force_directed_layout.run(edges, iterations, force_strength,\n                                      dampening, max_velocity, max_distance,\n                                      is_3d)\n    return {'edges': edges, 'nodes': nodes}", "summary": "Runs a force-directed algorithm on a graph, returning a data structure.\n\n    Args:\n        data: An adjacency list of tuples (ie. [(1,2),...])\n        iterations: (Optional) Number of FDL iterations to run in coordinate\n            generation\n        force_strength: (Optional) Strength of Coulomb and Hooke forces\n            (edit this to scale the distance between nodes)\n        dampening: (Optional) Multiplier to reduce force applied to nodes\n        max_velocity: (Optional) Maximum distance a node can move in one step\n        max_distance: (Optional) The maximum inter-node distance considered\n        is_3d: (Optional) Generates three-dimensional coordinates\n\n    Outputs a json-serializable Python object. To visualize, pass the output to\n    `jgraph.draw(...)`.", "name": "generate", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/patrickfuller/jgraph/blob/7297450f26ae8cba21914668a5aaa755de8aa14d/python/notebook.py#L136-L159", "code_lines": 21, "summary_length": 773}
{"code": "def compress(obj):\n    \"\"\"Outputs json without whitespace.\"\"\"\n    return json.dumps(obj, sort_keys=True, separators=(',', ':'),\n                      cls=CustomEncoder)", "summary": "Outputs json without whitespace.", "name": "compress", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/patrickfuller/jgraph/blob/7297450f26ae8cba21914668a5aaa755de8aa14d/python/json_formatter.py#L18-L21", "code_lines": 4, "summary_length": 32}
{"code": "def dumps(obj):\n    \"\"\"Outputs json with formatting edits + object handling.\"\"\"\n    return json.dumps(obj, indent=4, sort_keys=True, cls=CustomEncoder)", "summary": "Outputs json with formatting edits + object handling.", "name": "dumps", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/patrickfuller/jgraph/blob/7297450f26ae8cba21914668a5aaa755de8aa14d/python/json_formatter.py#L24-L26", "code_lines": 3, "summary_length": 53}
{"code": "def encode(self, obj):\n        \"\"\"Fired for every object.\"\"\"\n        s = super(CustomEncoder, self).encode(obj)\n        # If uncompressed, postprocess for formatting\n        if len(s.splitlines()) > 1:\n            s = self.postprocess(s)\n        return s", "summary": "Fired for every object.", "name": "encode", "complexity": 2, "num_dependencies": 4, "language": "python", "source_url": "https://github.com/patrickfuller/jgraph/blob/7297450f26ae8cba21914668a5aaa755de8aa14d/python/json_formatter.py#L31-L37", "code_lines": 7, "summary_length": 23}
{"code": "def postprocess(self, json_string):\n        \"\"\"Displays each entry on its own line.\"\"\"\n        is_compressing, is_hash, compressed, spaces = False, False, [], 0\n        for row in json_string.split('\\n'):\n            if is_compressing:\n                if (row[:spaces + 5] == ' ' * (spaces + 4) +\n                        ('\"' if is_hash else '{')):\n                    compressed.append(row.rstrip())\n                elif (len(row) > spaces and row[:spaces] == ' ' * spaces and\n                        re.match('[\\]\\}],?', row[spaces:].rstrip())):\n                    compressed.append(row.rstrip())\n                    is_compressing = False\n                else:\n                    compressed[-1] += ' ' + row.strip()\n            else:\n                compressed.append(row.rstrip())\n                if any(a in row for a in ['edges', 'nodes']):\n                    # Fix to handle issues that arise with empty lists\n                    if '[]' in row:\n                        continue\n                    spaces = sum(1 for _ in takewhile(str.isspace, row))\n                    is_compressing, is_hash = True, '{' in row\n        return '\\n'.join(compressed)", "summary": "Displays each entry on its own line.", "name": "postprocess", "complexity": 9, "num_dependencies": 15, "language": "python", "source_url": "https://github.com/patrickfuller/jgraph/blob/7297450f26ae8cba21914668a5aaa755de8aa14d/python/json_formatter.py#L39-L61", "code_lines": 23, "summary_length": 36}
{"code": "def run(edges, iterations=1000, force_strength=5.0, dampening=0.01,\n        max_velocity=2.0, max_distance=50, is_3d=True):\n    \"\"\"Runs a force-directed-layout algorithm on the input graph.\n\n    iterations - Number of FDL iterations to run in coordinate generation\n    force_strength - Strength of Coulomb and Hooke forces\n                     (edit this to scale the distance between nodes)\n    dampening - Multiplier to reduce force applied to nodes\n    max_velocity - Maximum distance a node can move in one step\n    max_distance - The maximum distance considered for interactions\n    \"\"\"\n\n    # Get a list of node ids from the edge data\n    nodes = set(e['source'] for e in edges) | set(e['target'] for e in edges)\n\n    # Convert to a data-storing object and initialize some values\n    d = 3 if is_3d else 2\n    nodes = {n: {'velocity': [0.0] * d, 'force': [0.0] * d} for n in nodes}\n\n    # Repeat n times (is there a more Pythonic way to do this?)\n    for _ in repeat(None, iterations):\n\n        # Add in Coulomb-esque node-node repulsive forces\n        for node1, node2 in combinations(nodes.values(), 2):\n            _coulomb(node1, node2, force_strength, max_distance)\n\n        # And Hooke-esque edge spring forces\n        for edge in edges:\n            _hooke(nodes[edge['source']], nodes[edge['target']],\n                   force_strength * edge.get('size', 1), max_distance)\n\n        # Move by resultant force\n        for node in nodes.values():\n            # Constrain the force to the bounds specified by input parameter\n            force = [_constrain(dampening * f, -max_velocity, max_velocity)\n                     for f in node['force']]\n            # Update velocities and reset force\n            node['velocity'] = [v + dv\n                                for v, dv in zip(node['velocity'], force)]\n            node['force'] = [0] * d\n\n    # Clean and return\n    for node in nodes.values():\n        del node['force']\n        node['location'] = node['velocity']\n        del node['velocity']\n        # Even if it's 2D, let's specify three dimensions\n        if not is_3d:\n            node['location'] += [0.0]\n    return nodes", "summary": "Runs a force-directed-layout algorithm on the input graph.\n\n    iterations - Number of FDL iterations to run in coordinate generation\n    force_strength - Strength of Coulomb and Hooke forces\n                     (edit this to scale the distance between nodes)\n    dampening - Multiplier to reduce force applied to nodes\n    max_velocity - Maximum distance a node can move in one step\n    max_distance - The maximum distance considered for interactions", "name": "run", "complexity": 7, "num_dependencies": 12, "language": "python", "source_url": "https://github.com/patrickfuller/jgraph/blob/7297450f26ae8cba21914668a5aaa755de8aa14d/python/force_directed_layout.py#L10-L59", "code_lines": 42, "summary_length": 452}
{"code": "def _coulomb(n1, n2, k, r):\n    \"\"\"Calculates Coulomb forces and updates node data.\"\"\"\n    # Get relevant positional data\n    delta = [x2 - x1 for x1, x2 in zip(n1['velocity'], n2['velocity'])]\n    distance = sqrt(sum(d ** 2 for d in delta))\n\n    # If the deltas are too small, use random values to keep things moving\n    if distance < 0.1:\n        delta = [uniform(0.1, 0.2) for _ in repeat(None, 3)]\n        distance = sqrt(sum(d ** 2 for d in delta))\n\n    # If the distance isn't huge (ie. Coulomb is negligible), calculate\n    if distance < r:\n        force = (k / distance) ** 2\n        n1['force'] = [f - force * d for f, d in zip(n1['force'], delta)]\n        n2['force'] = [f + force * d for f, d in zip(n2['force'], delta)]", "summary": "Calculates Coulomb forces and updates node data.", "name": "_coulomb", "complexity": 3, "num_dependencies": 9, "language": "python", "source_url": "https://github.com/patrickfuller/jgraph/blob/7297450f26ae8cba21914668a5aaa755de8aa14d/python/force_directed_layout.py#L62-L77", "code_lines": 14, "summary_length": 48}
{"code": "def run_step(context):\n    \"\"\"Wipe the entire context.\n\n    Args:\n        Context is a dictionary or dictionary-like.\n        Does not require any specific keys in context.\n    \"\"\"\n    logger.debug(\"started\")\n\n    context.clear()\n    logger.info(f\"Context wiped. New context size: {len(context)}\")\n\n    logger.debug(\"done\")", "summary": "Wipe the entire context.\n\n    Args:\n        Context is a dictionary or dictionary-like.\n        Does not require any specific keys in context.", "name": "run_step", "complexity": 1, "num_dependencies": 5, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/steps/contextclearall.py#L8-L20", "code_lines": 10, "summary_length": 142}
{"code": "def run_step(context):\n    \"\"\"pypyr step that checks if a file or directory path exists.\n\n    Args:\n        context: pypyr.context.Context. Mandatory.\n                 The following context key must exist\n                - pathsToCheck. str/path-like or list of str/paths.\n                                Path to file on disk to check.\n\n    All inputs support formatting expressions. Supports globs.\n\n    This step creates pathCheckOut in context, containing the results of the\n    path check operation.\n\n    pathCheckOut:\n        'inpath':\n            exists: true # bool. True if path exists.\n            count: 0 # int. Number of files found for in path.\n            found: ['path1', 'path2'] # list of strings. Paths of files found.\n\n    [count] is 0 if no files found. If you specified a single input\n    path to check and it exists, it's going to be 1. If you specified multiple\n    in paths or a glob expression that found more than 1 result, well, take a\n    guess.\n\n    [found] is a list of all the paths found for the [inpath]. If you passed\n    in a glob or globs, will contain the globs found for [inpath].\n\n    This means you can do an existence evaluation like this in a formatting\n    expression: '{pathCheckOut[inpathhere][exists]}'\n\n    Returns:\n        None. updates context arg.\n\n    Raises:\n        pypyr.errors.KeyNotInContextError: pathExists missing in context.\n        pypyr.errors.KeyInContextHasNoValueError: pathCheck exists but is None.\n\n    \"\"\"\n    logger.debug(\"started\")\n    context.assert_key_has_value(key='pathCheck', caller=__name__)\n\n    paths_to_check = context['pathCheck']\n\n    if not paths_to_check:\n        raise KeyInContextHasNoValueError(\"context['pathCheck'] must have a \"\n                                          f\"value for {__name__}.\")\n\n    # pathsToCheck can be a string or a list in case there are multiple paths\n    if isinstance(paths_to_check, list):\n        check_me = paths_to_check\n    else:\n        # assuming it's a str/path at this point\n        check_me = [paths_to_check]\n\n    out = {}\n    total_found = 0\n\n    for path in check_me:\n        logger.debug(f\"checking path: {path}\")\n        formatted_path = context.get_formatted_string(path)\n        found_paths = pypyr.utils.filesystem.get_glob(formatted_path)\n        no_of_paths = len(found_paths)\n        out[path] = {\n            'exists': no_of_paths > 0,\n            'count': no_of_paths,\n            'found': found_paths\n        }\n        total_found = total_found + no_of_paths\n\n    context['pathCheckOut'] = out\n\n    logger.info(f'checked {len(out)} path(s) and found {total_found}')\n    logger.debug(\"done\")", "summary": "pypyr step that checks if a file or directory path exists.\n\n    Args:\n        context: pypyr.context.Context. Mandatory.\n                 The following context key must exist\n                - pathsToCheck. str/path-like or list of str/paths.\n                                Path to file on disk to check.\n\n    All inputs support formatting expressions. Supports globs.\n\n    This step creates pathCheckOut in context, containing the results of the\n    path check operation.\n\n    pathCheckOut:\n        'inpath':\n            exists: true # bool. True if path exists.\n            count: 0 # int. Number of files found for in path.\n            found: ['path1', 'path2'] # list of strings. Paths of files found.\n\n    [count] is 0 if no files found. If you specified a single input\n    path to check and it exists, it's going to be 1. If you specified multiple\n    in paths or a glob expression that found more than 1 result, well, take a\n    guess.\n\n    [found] is a list of all the paths found for the [inpath]. If you passed\n    in a glob or globs, will contain the globs found for [inpath].\n\n    This means you can do an existence evaluation like this in a formatting\n    expression: '{pathCheckOut[inpathhere][exists]}'\n\n    Returns:\n        None. updates context arg.\n\n    Raises:\n        pypyr.errors.KeyNotInContextError: pathExists missing in context.\n        pypyr.errors.KeyInContextHasNoValueError: pathCheck exists but is None.", "name": "run_step", "complexity": 4, "num_dependencies": 11, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/steps/pathcheck.py#L10-L83", "code_lines": 57, "summary_length": 1434}
{"code": "def run_step(context):\n    \"\"\"Write payload out to json file.\n\n    Args:\n        context: pypyr.context.Context. Mandatory.\n                 The following context keys expected:\n                - fileWriteJson\n                    - path. mandatory. path-like. Write output file to\n                      here. Will create directories in path for you.\n                    - payload. optional. Write this key to output file. If not\n                      specified, output entire context.\n\n    Returns:\n        None.\n\n    Raises:\n        pypyr.errors.KeyNotInContextError: fileWriteJson or\n            fileWriteJson['path'] missing in context.\n        pypyr.errors.KeyInContextHasNoValueError: fileWriteJson or\n            fileWriteJson['path'] exists but is None.\n\n    \"\"\"\n    logger.debug(\"started\")\n    context.assert_child_key_has_value('fileWriteJson', 'path', __name__)\n\n    out_path = context.get_formatted_string(context['fileWriteJson']['path'])\n    # doing it like this to safeguard against accidentally dumping all context\n    # with potentially sensitive values in it to disk if payload exists but is\n    # None.\n    is_payload_specified = 'payload' in context['fileWriteJson']\n\n    logger.debug(f\"opening destination file for writing: {out_path}\")\n    os.makedirs(os.path.abspath(os.path.dirname(out_path)), exist_ok=True)\n    with open(out_path, 'w') as outfile:\n        if is_payload_specified:\n            payload = context['fileWriteJson']['payload']\n            formatted_iterable = context.get_formatted_iterable(payload)\n        else:\n            formatted_iterable = context.get_formatted_iterable(context)\n\n        json.dump(formatted_iterable, outfile, indent=2, ensure_ascii=False)\n\n    logger.info(f\"formatted context content and wrote to {out_path}\")\n    logger.debug(\"done\")", "summary": "Write payload out to json file.\n\n    Args:\n        context: pypyr.context.Context. Mandatory.\n                 The following context keys expected:\n                - fileWriteJson\n                    - path. mandatory. path-like. Write output file to\n                      here. Will create directories in path for you.\n                    - payload. optional. Write this key to output file. If not\n                      specified, output entire context.\n\n    Returns:\n        None.\n\n    Raises:\n        pypyr.errors.KeyNotInContextError: fileWriteJson or\n            fileWriteJson['path'] missing in context.\n        pypyr.errors.KeyInContextHasNoValueError: fileWriteJson or\n            fileWriteJson['path'] exists but is None.", "name": "run_step", "complexity": 2, "num_dependencies": 13, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/steps/filewritejson.py#L10-L53", "code_lines": 36, "summary_length": 730}
{"code": "def run_step(context):\n    \"\"\"Run another pipeline from this step.\n\n    The parent pipeline is the current, executing pipeline. The invoked, or\n    child pipeline is the pipeline you are calling from this step.\n\n    Args:\n        context: dictionary-like pypyr.context.Context. context is mandatory.\n                 Uses the following context keys in context:\n            - pype\n                - name. mandatory. str. Name of pipeline to execute. This\n                  {name}.yaml must exist in the working directory/pipelines\n                  dir.\n                - pipeArg. string. optional. String to pass to the\n                  context_parser - the equivalent to context arg on the\n                  pypyr cli. Only used if skipParse==False.\n                - raiseError. bool. optional. Defaults to True. If False, log,\n                  but swallow any errors that happen during the invoked\n                  pipeline execution. Swallowing means that the current/parent\n                  pipeline will carry on with the next step even if an error\n                  occurs in the invoked pipeline.\n                - skipParse. bool. optional. Defaults to True. skip the\n                  context_parser on the invoked pipeline.\n                - useParentContext. optional. bool. Defaults to True. Pass the\n                  current (i.e parent) pipeline context to the invoked (child)\n                  pipeline.\n                - loader: str. optional. Absolute name of pipeline loader\n                  module. If not specified will use\n                  pypyr.pypeloaders.fileloader.\n\n    Returns:\n        None\n\n    Raises:\n        pypyr.errors.KeyNotInContextError: if ['pype'] or ['pype']['name']\n                                           is missing.\n        pypyr.errors.KeyInContextHasNoValueError: ['pype']['name'] exists but\n                                                  is empty.\n    \"\"\"\n    logger.debug(\"started\")\n\n    (pipeline_name,\n     use_parent_context,\n     pipe_arg,\n     skip_parse,\n     raise_error,\n     loader,\n     ) = get_arguments(context)\n\n    try:\n        if use_parent_context:\n            logger.info(f\"pyping {pipeline_name}, using parent context.\")\n            pipelinerunner.load_and_run_pipeline(\n                pipeline_name=pipeline_name,\n                pipeline_context_input=pipe_arg,\n                context=context,\n                parse_input=not skip_parse,\n                loader=loader\n            )\n        else:\n            logger.info(f\"pyping {pipeline_name}, without parent context.\")\n            pipelinerunner.load_and_run_pipeline(\n                pipeline_name=pipeline_name,\n                pipeline_context_input=pipe_arg,\n                working_dir=context.working_dir,\n                parse_input=not skip_parse,\n                loader=loader\n            )\n\n        logger.info(f\"pyped {pipeline_name}.\")\n    except Exception as ex_info:\n        # yes, yes, don't catch Exception. Have to, though, in order to swallow\n        # errs if !raise_error\n        logger.error(f\"Something went wrong pyping {pipeline_name}. \"\n                     f\"{type(ex_info).__name__}: {ex_info}\")\n\n        if raise_error:\n            logger.debug(\"Raising original exception to caller.\")\n            raise\n        else:\n            logger.debug(\n                f\"raiseError is False. Swallowing error in {pipeline_name}.\")\n\n    logger.debug(\"done\")", "summary": "Run another pipeline from this step.\n\n    The parent pipeline is the current, executing pipeline. The invoked, or\n    child pipeline is the pipeline you are calling from this step.\n\n    Args:\n        context: dictionary-like pypyr.context.Context. context is mandatory.\n                 Uses the following context keys in context:\n            - pype\n                - name. mandatory. str. Name of pipeline to execute. This\n                  {name}.yaml must exist in the working directory/pipelines\n                  dir.\n                - pipeArg. string. optional. String to pass to the\n                  context_parser - the equivalent to context arg on the\n                  pypyr cli. Only used if skipParse==False.\n                - raiseError. bool. optional. Defaults to True. If False, log,\n                  but swallow any errors that happen during the invoked\n                  pipeline execution. Swallowing means that the current/parent\n                  pipeline will carry on with the next step even if an error\n                  occurs in the invoked pipeline.\n                - skipParse. bool. optional. Defaults to True. skip the\n                  context_parser on the invoked pipeline.\n                - useParentContext. optional. bool. Defaults to True. Pass the\n                  current (i.e parent) pipeline context to the invoked (child)\n                  pipeline.\n                - loader: str. optional. Absolute name of pipeline loader\n                  module. If not specified will use\n                  pypyr.pypeloaders.fileloader.\n\n    Returns:\n        None\n\n    Raises:\n        pypyr.errors.KeyNotInContextError: if ['pype'] or ['pype']['name']\n                                           is missing.\n        pypyr.errors.KeyInContextHasNoValueError: ['pype']['name'] exists but\n                                                  is empty.", "name": "run_step", "complexity": 4, "num_dependencies": 11, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/steps/pype.py#L10-L93", "code_lines": 75, "summary_length": 1876}
{"code": "def get_arguments(context):\n    \"\"\"Parse arguments for pype from context and assign default values.\n\n    Args:\n        context: pypyr.context.Context. context is mandatory.\n\n    Returns:\n        tuple (pipeline_name, #str\n               use_parent_context, #bool\n               pipe_arg, #str\n               skip_parse, #bool\n               raise_error #bool\n               )\n\n    Raises:\n       pypyr.errors.KeyNotInContextError: if ['pype']['name'] is missing.\n       pypyr.errors.KeyInContextHasNoValueError: if ['pype']['name'] exists but\n                                                 is None.\n    \"\"\"\n    context.assert_key_has_value(key='pype', caller=__name__)\n    pype = context.get_formatted('pype')\n\n    try:\n        pipeline_name = pype['name']\n\n        if pipeline_name is None:\n            raise KeyInContextHasNoValueError(\n                \"pypyr.steps.pype ['pype']['name'] exists but is empty.\")\n    except KeyError as err:\n        raise KeyNotInContextError(\n            \"pypyr.steps.pype missing 'name' in the 'pype' context item. \"\n            \"You need to specify the pipeline name to run another \"\n            \"pipeline.\") from err\n\n    use_parent_context = pype.get('useParentContext', True)\n    pipe_arg = pype.get('pipeArg', None)\n    skip_parse = pype.get('skipParse', True)\n    raise_error = pype.get('raiseError', True)\n    loader = pype.get('loader', None)\n\n    return (\n        pipeline_name,\n        use_parent_context,\n        pipe_arg,\n        skip_parse,\n        raise_error,\n        loader,\n    )", "summary": "Parse arguments for pype from context and assign default values.\n\n    Args:\n        context: pypyr.context.Context. context is mandatory.\n\n    Returns:\n        tuple (pipeline_name, #str\n               use_parent_context, #bool\n               pipe_arg, #str\n               skip_parse, #bool\n               raise_error #bool\n               )\n\n    Raises:\n       pypyr.errors.KeyNotInContextError: if ['pype']['name'] is missing.\n       pypyr.errors.KeyInContextHasNoValueError: if ['pype']['name'] exists but\n                                                 is None.", "name": "get_arguments", "complexity": 3, "num_dependencies": 9, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/steps/pype.py#L96-L143", "code_lines": 41, "summary_length": 565}
{"code": "def get_pipeline_path(pipeline_name, working_directory):\n    \"\"\"Look for the pipeline in the various places it could be.\n\n    First checks the cwd. Then checks pypyr/pipelines dir.\n\n    Args:\n        pipeline_name: string. Name of pipeline to find\n        working_directory: string. Path in which to look for pipeline_name.yaml\n\n    Returns:\n        Absolute path to the pipeline_name.yaml file\n\n    Raises:\n        PipelineNotFoundError: if pipeline_name.yaml not found in working_dir\n                               or in {pypyr install dir}/pipelines.\n\n    \"\"\"\n    logger.debug(\"starting\")\n\n    # look for name.yaml in the pipelines/ sub-directory\n    logger.debug(f\"current directory is {working_directory}\")\n\n    # looking for {cwd}/pipelines/[pipeline_name].yaml\n    pipeline_path = os.path.abspath(os.path.join(\n        working_directory,\n        'pipelines',\n        pipeline_name + '.yaml'))\n\n    if os.path.isfile(pipeline_path):\n        logger.debug(f\"Found {pipeline_path}\")\n    else:\n        logger.debug(f\"{pipeline_name} not found in current \"\n                     \"directory/pipelines folder. Looking in pypyr install \"\n                     \"directory instead.\")\n        pypyr_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        logger.debug(f\"pypyr installation directory is: {pypyr_dir}\")\n        pipeline_path = os.path.abspath(os.path.join(\n            pypyr_dir,\n            'pipelines',\n            pipeline_name + '.yaml'))\n\n        if os.path.isfile(pipeline_path):\n            logger.debug(f\"Found {pipeline_path}\")\n        else:\n            raise PipelineNotFoundError(f\"{pipeline_name}.yaml not found in \"\n                                        f\"either \"\n                                        f\"{working_directory}/pipelines \"\n                                        f\"or {pypyr_dir}/pipelines\")\n\n    logger.debug(\"done\")\n    return pipeline_path", "summary": "Look for the pipeline in the various places it could be.\n\n    First checks the cwd. Then checks pypyr/pipelines dir.\n\n    Args:\n        pipeline_name: string. Name of pipeline to find\n        working_directory: string. Path in which to look for pipeline_name.yaml\n\n    Returns:\n        Absolute path to the pipeline_name.yaml file\n\n    Raises:\n        PipelineNotFoundError: if pipeline_name.yaml not found in working_dir\n                               or in {pypyr install dir}/pipelines.", "name": "get_pipeline_path", "complexity": 3, "num_dependencies": 17, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/pypeloaders/fileloader.py#L11-L61", "code_lines": 41, "summary_length": 489}
{"code": "def get_pipeline_definition(pipeline_name, working_dir):\n    \"\"\"Open and parse the pipeline definition yaml.\n\n    Parses pipeline yaml and returns dictionary representing the pipeline.\n\n    pipeline_name.yaml should be in the working_dir/pipelines/ directory.\n\n    Args:\n        pipeline_name: string. Name of pipeline. This will be the file-name of\n                       the pipeline - i.e {pipeline_name}.yaml\n        working_dir: path. Start looking in\n                           ./working_dir/pipelines/pipeline_name.yaml\n\n    Returns:\n        dict describing the pipeline, parsed from the pipeline yaml.\n\n    Raises:\n        FileNotFoundError: pipeline_name.yaml not found in the various pipeline\n                           dirs.\n\n    \"\"\"\n    logger.debug(\"starting\")\n\n    pipeline_path = get_pipeline_path(\n        pipeline_name=pipeline_name,\n        working_directory=working_dir)\n\n    logger.debug(f\"Trying to open pipeline at path {pipeline_path}\")\n    try:\n        with open(pipeline_path) as yaml_file:\n            pipeline_definition = pypyr.yaml.get_pipeline_yaml(\n                yaml_file)\n            logger.debug(\n                f\"found {len(pipeline_definition)} stages in pipeline.\")\n    except FileNotFoundError:\n        logger.error(\n            \"The pipeline doesn't exist. Looking for a file here: \"\n            f\"{pipeline_name}.yaml in the /pipelines sub directory.\")\n        raise\n\n    logger.debug(\"pipeline definition loaded\")\n\n    logger.debug(\"done\")\n    return pipeline_definition", "summary": "Open and parse the pipeline definition yaml.\n\n    Parses pipeline yaml and returns dictionary representing the pipeline.\n\n    pipeline_name.yaml should be in the working_dir/pipelines/ directory.\n\n    Args:\n        pipeline_name: string. Name of pipeline. This will be the file-name of\n                       the pipeline - i.e {pipeline_name}.yaml\n        working_dir: path. Start looking in\n                           ./working_dir/pipelines/pipeline_name.yaml\n\n    Returns:\n        dict describing the pipeline, parsed from the pipeline yaml.\n\n    Raises:\n        FileNotFoundError: pipeline_name.yaml not found in the various pipeline\n                           dirs.", "name": "get_pipeline_definition", "complexity": 2, "num_dependencies": 10, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/pypeloaders/fileloader.py#L64-L107", "code_lines": 34, "summary_length": 671}
{"code": "def to_yaml(cls, representer, node):\n        \"\"\"How to serialize this class back to yaml.\"\"\"\n        return representer.represent_scalar(cls.yaml_tag, node.value)", "summary": "How to serialize this class back to yaml.", "name": "to_yaml", "complexity": 1, "num_dependencies": 1, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/dsl.py#L55-L57", "code_lines": 3, "summary_length": 41}
{"code": "def get_value(self, context):\n        \"\"\"Run python eval on the input string.\"\"\"\n        if self.value:\n            return expressions.eval_string(self.value, context)\n        else:\n            # Empty input raises cryptic EOF syntax err, this more human\n            # friendly\n            raise ValueError('!py string expression is empty. It must be a '\n                             'valid python expression instead.')", "summary": "Run python eval on the input string.", "name": "get_value", "complexity": 2, "num_dependencies": 2, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/dsl.py#L107-L115", "code_lines": 9, "summary_length": 36}
{"code": "def foreach_loop(self, context):\n        \"\"\"Run step once for each item in foreach_items.\n\n        On each iteration, the invoked step can use context['i'] to get the\n        current iterator value.\n\n        Args:\n            context: (pypyr.context.Context) The pypyr context. This arg will\n                     mutate.\n        \"\"\"\n        logger.debug(\"starting\")\n\n        # Loop decorators only evaluated once, not for every step repeat\n        # execution.\n        foreach = context.get_formatted_iterable(self.foreach_items)\n\n        foreach_length = len(foreach)\n\n        logger.info(f\"foreach decorator will loop {foreach_length} times.\")\n\n        for i in foreach:\n            logger.info(f\"foreach: running step {i}\")\n            # the iterator must be available to the step when it executes\n            context['i'] = i\n            # conditional operators apply to each iteration, so might be an\n            # iteration run, skips or swallows.\n            self.run_conditional_decorators(context)\n            logger.debug(f\"foreach: done step {i}\")\n\n        logger.debug(f\"foreach decorator looped {foreach_length} times.\")\n        logger.debug(\"done\")", "summary": "Run step once for each item in foreach_items.\n\n        On each iteration, the invoked step can use context['i'] to get the\n        current iterator value.\n\n        Args:\n            context: (pypyr.context.Context) The pypyr context. This arg will\n                     mutate.", "name": "foreach_loop", "complexity": 2, "num_dependencies": 9, "language": "python", "source_url": "https://github.com/pypyr/pypyr-cli/blob/4003f999cd5eb030b4c7407317de728f5115a80f/pypyr/dsl.py#L253-L283", "code_lines": 24, "summary_length": 276}
